{"ast":null,"code":"import { Color, MathUtils } from \"three\";\nclass Lut {\n  constructor(colormap, count = 32) {\n    this.isLut = true;\n    this.lut = [];\n    this.map = [];\n    this.n = 0;\n    this.minV = 0;\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value);\n    }\n    return this;\n  }\n  setMin(min) {\n    this.minV = min;\n    return this;\n  }\n  setMax(max) {\n    this.maxV = max;\n    return this;\n  }\n  setColorMap(colormap, count = 32) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n    this.n = count;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    this.lut.length = 0;\n    this.lut.push(new Color(this.map[0][1]));\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step;\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0];\n          const max = this.map[j + 1][0];\n          minColor.setHex(this.map[j][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j + 1][1], \"linear-srgb\");\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n          this.lut.push(color);\n        }\n      }\n    }\n    this.lut.push(new Color(this.map[this.map.length - 1][1]));\n    return this;\n  }\n  copy(lut) {\n    this.lut = lut.lut;\n    this.map = lut.map;\n    this.n = lut.n;\n    this.minV = lut.minV;\n    this.maxV = lut.maxV;\n    return this;\n  }\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\n    const colorPosition = Math.round(alpha * this.n);\n    return this.lut[colorPosition];\n  }\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors;\n    return this;\n  }\n  createCanvas() {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = this.n;\n    this.updateCanvas(canvas);\n    return canvas;\n  }\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n    const imageData = ctx.getImageData(0, 0, 1, this.n);\n    const data = imageData.data;\n    let k = 0;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    const finalColor = new Color();\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0];\n          const max = this.map[j][0];\n          minColor.setHex(this.map[j - 1][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j][1], \"linear-srgb\");\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n          data[k * 4] = Math.round(finalColor.r * 255);\n          data[k * 4 + 1] = Math.round(finalColor.g * 255);\n          data[k * 4 + 2] = Math.round(finalColor.b * 255);\n          data[k * 4 + 3] = 255;\n          k += 1;\n        }\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n}\nconst ColorMapKeywords = {\n  rainbow: [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],\n  cooltowarm: [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],\n  blackbody: [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],\n  grayscale: [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]\n};\nexport { ColorMapKeywords, Lut };","map":{"version":3,"names":["Color","MathUtils","Lut","constructor","colormap","count","isLut","lut","map","n","minV","maxV","setColorMap","set","value","copy","setMin","min","setMax","max","ColorMapKeywords","rainbow","step","minColor","maxColor","length","push","i","alpha","j","setHex","color","lerpColors","getColor","clamp","colorPosition","Math","round","addColorMap","name","arrayOfColors","createCanvas","canvas","document","createElement","width","height","updateCanvas","ctx","getContext","imageData","getImageData","data","k","finalColor","r","g","b","putImageData","cooltowarm","blackbody","grayscale"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/math/Lut.js"],"sourcesContent":["import { Color, MathUtils } from \"three\";\nclass Lut {\n  constructor(colormap, count = 32) {\n    this.isLut = true;\n    this.lut = [];\n    this.map = [];\n    this.n = 0;\n    this.minV = 0;\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value);\n    }\n    return this;\n  }\n  setMin(min) {\n    this.minV = min;\n    return this;\n  }\n  setMax(max) {\n    this.maxV = max;\n    return this;\n  }\n  setColorMap(colormap, count = 32) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n    this.n = count;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    this.lut.length = 0;\n    this.lut.push(new Color(this.map[0][1]));\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step;\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0];\n          const max = this.map[j + 1][0];\n          minColor.setHex(this.map[j][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j + 1][1], \"linear-srgb\");\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n          this.lut.push(color);\n        }\n      }\n    }\n    this.lut.push(new Color(this.map[this.map.length - 1][1]));\n    return this;\n  }\n  copy(lut) {\n    this.lut = lut.lut;\n    this.map = lut.map;\n    this.n = lut.n;\n    this.minV = lut.minV;\n    this.maxV = lut.maxV;\n    return this;\n  }\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\n    const colorPosition = Math.round(alpha * this.n);\n    return this.lut[colorPosition];\n  }\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors;\n    return this;\n  }\n  createCanvas() {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = this.n;\n    this.updateCanvas(canvas);\n    return canvas;\n  }\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext(\"2d\", { alpha: false });\n    const imageData = ctx.getImageData(0, 0, 1, this.n);\n    const data = imageData.data;\n    let k = 0;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    const finalColor = new Color();\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0];\n          const max = this.map[j][0];\n          minColor.setHex(this.map[j - 1][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j][1], \"linear-srgb\");\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n          data[k * 4] = Math.round(finalColor.r * 255);\n          data[k * 4 + 1] = Math.round(finalColor.g * 255);\n          data[k * 4 + 2] = Math.round(finalColor.b * 255);\n          data[k * 4 + 3] = 255;\n          k += 1;\n        }\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n}\nconst ColorMapKeywords = {\n  rainbow: [\n    [0, 255],\n    [0.2, 65535],\n    [0.5, 65280],\n    [0.8, 16776960],\n    [1, 16711680]\n  ],\n  cooltowarm: [\n    [0, 3952322],\n    [0.2, 10206463],\n    [0.5, 14474460],\n    [0.8, 16163717],\n    [1, 11797542]\n  ],\n  blackbody: [\n    [0, 0],\n    [0.2, 7864320],\n    [0.5, 15086080],\n    [0.8, 16776960],\n    [1, 16777215]\n  ],\n  grayscale: [\n    [0, 0],\n    [0.2, 4210752],\n    [0.5, 8355712],\n    [0.8, 12566463],\n    [1, 16777215]\n  ]\n};\nexport {\n  ColorMapKeywords,\n  Lut\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}