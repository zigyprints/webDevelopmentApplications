{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, FrontSide, RepeatWrapping, Color, MeshPhongMaterial, Vector2, DefaultLoadingManager, TextureLoader } from \"three\";\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === \"\" ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  setMaterialOptions(value) {\n    this.materialOptions = value;\n    return this;\n  }\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n  parse(text, path) {\n    const lines = text.split(\"\\n\");\n    let info = {};\n    const delimiter_pattern = /\\s+/;\n    const materialsInfo = {};\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      line = line.trim();\n      if (line.length === 0 || line.charAt(0) === \"#\") {\n        continue;\n      }\n      const pos = line.indexOf(\" \");\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      let value = pos >= 0 ? line.substring(pos + 1) : \"\";\n      value = value.trim();\n      if (key === \"newmtl\") {\n        info = {\n          name: value\n        };\n        materialsInfo[value] = info;\n      } else {\n        if (key === \"ka\" || key === \"kd\" || key === \"ks\" || key === \"ke\") {\n          const ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n}\nclass MaterialCreator {\n  constructor(baseUrl = \"\", options = {}) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = \"anonymous\";\n    this.side = this.options.side !== void 0 ? this.options.side : FrontSide;\n    this.wrap = this.options.wrap !== void 0 ? this.options.wrap : RepeatWrapping;\n  }\n  setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  }\n  setManager(value) {\n    this.manager = value;\n  }\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  }\n  convert(materialsInfo) {\n    if (!this.options) return materialsInfo;\n    const converted = {};\n    for (const mn in materialsInfo) {\n      const mat = materialsInfo[mn];\n      const covmat = {};\n      converted[mn] = covmat;\n      for (const prop in mat) {\n        let save = true;\n        let value = mat[prop];\n        const lprop = prop.toLowerCase();\n        switch (lprop) {\n          case \"kd\":\n          case \"ka\":\n          case \"ks\":\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                save = false;\n              }\n            }\n            break;\n          default:\n            break;\n        }\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n    return converted;\n  }\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  }\n  getIndex(materialName) {\n    return this.nameLookup[materialName];\n  }\n  getAsArray() {\n    let index = 0;\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n    return this.materialsArray;\n  }\n  create(materialName) {\n    if (this.materials[materialName] === void 0) {\n      this.createMaterial_(materialName);\n    }\n    return this.materials[materialName];\n  }\n  createMaterial_(materialName) {\n    const scope = this;\n    const mat = this.materialsInfo[materialName];\n    const params = {\n      name: materialName,\n      side: this.side\n    };\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== \"string\" || url === \"\") return \"\";\n      if (/^https?:\\/\\//i.test(url)) return url;\n      return baseUrl + url;\n    }\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return;\n      const texParams = scope.getTextureParams(value, params);\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      params[mapType] = map;\n    }\n    for (const prop in mat) {\n      const value = mat[prop];\n      let n;\n      if (value === \"\") continue;\n      switch (prop.toLowerCase()) {\n        case \"kd\":\n          params.color = new Color().fromArray(value);\n          break;\n        case \"ks\":\n          params.specular = new Color().fromArray(value);\n          break;\n        case \"ke\":\n          params.emissive = new Color().fromArray(value);\n          break;\n        case \"map_kd\":\n          setMapForType(\"map\", value);\n          break;\n        case \"map_ks\":\n          setMapForType(\"specularMap\", value);\n          break;\n        case \"map_ke\":\n          setMapForType(\"emissiveMap\", value);\n          break;\n        case \"norm\":\n          setMapForType(\"normalMap\", value);\n          break;\n        case \"map_bump\":\n        case \"bump\":\n          setMapForType(\"bumpMap\", value);\n          break;\n        case \"map_d\":\n          setMapForType(\"alphaMap\", value);\n          params.transparent = true;\n          break;\n        case \"ns\":\n          params.shininess = parseFloat(value);\n          break;\n        case \"d\":\n          n = parseFloat(value);\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n          break;\n        case \"tr\":\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty) n = 1 - n;\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  }\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    const items = value.split(/\\s+/);\n    let pos;\n    pos = items.indexOf(\"-bm\");\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n    pos = items.indexOf(\"-s\");\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    pos = items.indexOf(\"-o\");\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    texParams.url = items.join(\" \").trim();\n    return texParams;\n  }\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== void 0 ? this.manager : DefaultLoadingManager;\n    let loader = manager.getHandler(url);\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n    const texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== void 0) texture.mapping = mapping;\n    return texture;\n  }\n}\nexport { MTLLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","FrontSide","RepeatWrapping","Color","MeshPhongMaterial","Vector2","DefaultLoadingManager","TextureLoader","MTLLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterialOptions","value","materialOptions","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","name","ss","parseFloat","materialCreator","MaterialCreator","resourcePath","setCrossOrigin","crossOrigin","setManager","setMaterials","baseUrl","options","materials","materialsArray","nameLookup","side","wrap","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","preload","create","getIndex","materialName","getAsArray","index","createMaterial_","params","resolveURL","test","setMapForType","mapType","texParams","getTextureParams","map","loadTexture","repeat","copy","scale","offset","wrapS","wrapT","n","color","fromArray","specular","emissive","transparent","shininess","opacity","invertTrProperty","matParams","items","bumpScale","splice","set","join","mapping","getHandler","texture"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/loaders/MTLLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, FrontSide, RepeatWrapping, Color, MeshPhongMaterial, Vector2, DefaultLoadingManager, TextureLoader } from \"three\";\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === \"\" ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  setMaterialOptions(value) {\n    this.materialOptions = value;\n    return this;\n  }\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n  parse(text, path) {\n    const lines = text.split(\"\\n\");\n    let info = {};\n    const delimiter_pattern = /\\s+/;\n    const materialsInfo = {};\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      line = line.trim();\n      if (line.length === 0 || line.charAt(0) === \"#\") {\n        continue;\n      }\n      const pos = line.indexOf(\" \");\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      let value = pos >= 0 ? line.substring(pos + 1) : \"\";\n      value = value.trim();\n      if (key === \"newmtl\") {\n        info = { name: value };\n        materialsInfo[value] = info;\n      } else {\n        if (key === \"ka\" || key === \"kd\" || key === \"ks\" || key === \"ke\") {\n          const ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n}\nclass MaterialCreator {\n  constructor(baseUrl = \"\", options = {}) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = \"anonymous\";\n    this.side = this.options.side !== void 0 ? this.options.side : FrontSide;\n    this.wrap = this.options.wrap !== void 0 ? this.options.wrap : RepeatWrapping;\n  }\n  setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  }\n  setManager(value) {\n    this.manager = value;\n  }\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  }\n  convert(materialsInfo) {\n    if (!this.options)\n      return materialsInfo;\n    const converted = {};\n    for (const mn in materialsInfo) {\n      const mat = materialsInfo[mn];\n      const covmat = {};\n      converted[mn] = covmat;\n      for (const prop in mat) {\n        let save = true;\n        let value = mat[prop];\n        const lprop = prop.toLowerCase();\n        switch (lprop) {\n          case \"kd\":\n          case \"ka\":\n          case \"ks\":\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                save = false;\n              }\n            }\n            break;\n          default:\n            break;\n        }\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n    return converted;\n  }\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  }\n  getIndex(materialName) {\n    return this.nameLookup[materialName];\n  }\n  getAsArray() {\n    let index = 0;\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n    return this.materialsArray;\n  }\n  create(materialName) {\n    if (this.materials[materialName] === void 0) {\n      this.createMaterial_(materialName);\n    }\n    return this.materials[materialName];\n  }\n  createMaterial_(materialName) {\n    const scope = this;\n    const mat = this.materialsInfo[materialName];\n    const params = {\n      name: materialName,\n      side: this.side\n    };\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== \"string\" || url === \"\")\n        return \"\";\n      if (/^https?:\\/\\//i.test(url))\n        return url;\n      return baseUrl + url;\n    }\n    function setMapForType(mapType, value) {\n      if (params[mapType])\n        return;\n      const texParams = scope.getTextureParams(value, params);\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      params[mapType] = map;\n    }\n    for (const prop in mat) {\n      const value = mat[prop];\n      let n;\n      if (value === \"\")\n        continue;\n      switch (prop.toLowerCase()) {\n        case \"kd\":\n          params.color = new Color().fromArray(value);\n          break;\n        case \"ks\":\n          params.specular = new Color().fromArray(value);\n          break;\n        case \"ke\":\n          params.emissive = new Color().fromArray(value);\n          break;\n        case \"map_kd\":\n          setMapForType(\"map\", value);\n          break;\n        case \"map_ks\":\n          setMapForType(\"specularMap\", value);\n          break;\n        case \"map_ke\":\n          setMapForType(\"emissiveMap\", value);\n          break;\n        case \"norm\":\n          setMapForType(\"normalMap\", value);\n          break;\n        case \"map_bump\":\n        case \"bump\":\n          setMapForType(\"bumpMap\", value);\n          break;\n        case \"map_d\":\n          setMapForType(\"alphaMap\", value);\n          params.transparent = true;\n          break;\n        case \"ns\":\n          params.shininess = parseFloat(value);\n          break;\n        case \"d\":\n          n = parseFloat(value);\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n          break;\n        case \"tr\":\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty)\n            n = 1 - n;\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  }\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    const items = value.split(/\\s+/);\n    let pos;\n    pos = items.indexOf(\"-bm\");\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n    pos = items.indexOf(\"-s\");\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    pos = items.indexOf(\"-o\");\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    texParams.url = items.join(\" \").trim();\n    return texParams;\n  }\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== void 0 ? this.manager : DefaultLoadingManager;\n    let loader = manager.getHandler(url);\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n    if (loader.setCrossOrigin)\n      loader.setCrossOrigin(this.crossOrigin);\n    const texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== void 0)\n      texture.mapping = mapping;\n    return texture;\n  }\n}\nexport {\n  MTLLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}