{"ast":null,"code":"import * as THREE from 'three';\nclass SpotLightMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        depth: {\n          value: null\n        },\n        opacity: {\n          value: 1\n        },\n        attenuation: {\n          value: 2.5\n        },\n        anglePower: {\n          value: 12\n        },\n        spotPosition: {\n          value: new THREE.Vector3(0, 0, 0)\n        },\n        lightColor: {\n          value: new THREE.Color('white')\n        },\n        cameraNear: {\n          value: 0\n        },\n        cameraFar: {\n          value: 1\n        },\n        resolution: {\n          value: new THREE.Vector2(0, 0)\n        }\n      },\n      transparent: true,\n      depthWrite: false,\n      vertexShader: /* glsl */\n      `\n      varying vec3 vNormal;\n      varying vec3 vWorldPosition;\n      varying float vViewZ;\n      varying float vIntensity;\n      uniform vec3 spotPosition;\n      uniform float attenuation;      \n\n      void main() {\n        // compute intensity\n        vNormal = normalize( normalMatrix * normal );\n        vec4 worldPosition\t= modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n        vec4 viewPosition = viewMatrix * worldPosition;\n        vViewZ = viewPosition.z;\n        float intensity\t= distance(worldPosition.xyz, spotPosition) / attenuation;\n        intensity\t= 1.0 - clamp(intensity, 0.0, 1.0);\n        vIntensity = intensity;        \n        // set gl_Position\n        gl_Position\t= projectionMatrix * viewPosition;\n\n      }`,\n      fragmentShader: /* glsl */\n      `\n      #include <packing>\n\n      varying vec3 vNormal;\n      varying vec3 vWorldPosition;\n      uniform vec3 lightColor;\n      uniform vec3 spotPosition;\n      uniform float attenuation;\n      uniform float anglePower;\n      uniform sampler2D depth;\n      uniform vec2 resolution;\n      uniform float cameraNear;\n      uniform float cameraFar;\n      varying float vViewZ;\n      varying float vIntensity;\n      uniform float opacity;\n\n      float readDepth( sampler2D depthSampler, vec2 coord ) {\n        float fragCoordZ = texture2D( depthSampler, coord ).x;\n        float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n        return viewZ;\n      }\n\n      void main() {\n        float d = 1.0;\n        bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n        if (isSoft) {\n          vec2 sUv = gl_FragCoord.xy / resolution;\n          d = readDepth(depth, sUv);\n        }\n        float intensity = vIntensity;\n        vec3 normal\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n        float angleIntensity\t= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );\n        intensity\t*= angleIntensity;\n        // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n        if (isSoft) {\n          intensity\t*= smoothstep(0., 1., vViewZ - d);\n        }\n        gl_FragColor = vec4(lightColor, intensity * opacity);\n\n        #include <tonemapping_fragment>\n\t      #include <${parseInt(THREE.REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n      }`\n    });\n  }\n}\nexport { SpotLightMaterial };","map":{"version":3,"names":["THREE","SpotLightMaterial","ShaderMaterial","constructor","uniforms","depth","value","opacity","attenuation","anglePower","spotPosition","Vector3","lightColor","Color","cameraNear","cameraFar","resolution","Vector2","transparent","depthWrite","vertexShader","fragmentShader","parseInt","REVISION","replace"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/@react-three/drei/materials/SpotLightMaterial.js"],"sourcesContent":["import * as THREE from 'three';\n\nclass SpotLightMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        depth: {\n          value: null\n        },\n        opacity: {\n          value: 1\n        },\n        attenuation: {\n          value: 2.5\n        },\n        anglePower: {\n          value: 12\n        },\n        spotPosition: {\n          value: new THREE.Vector3(0, 0, 0)\n        },\n        lightColor: {\n          value: new THREE.Color('white')\n        },\n        cameraNear: {\n          value: 0\n        },\n        cameraFar: {\n          value: 1\n        },\n        resolution: {\n          value: new THREE.Vector2(0, 0)\n        }\n      },\n      transparent: true,\n      depthWrite: false,\n      vertexShader:\n      /* glsl */\n      `\n      varying vec3 vNormal;\n      varying vec3 vWorldPosition;\n      varying float vViewZ;\n      varying float vIntensity;\n      uniform vec3 spotPosition;\n      uniform float attenuation;      \n\n      void main() {\n        // compute intensity\n        vNormal = normalize( normalMatrix * normal );\n        vec4 worldPosition\t= modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n        vec4 viewPosition = viewMatrix * worldPosition;\n        vViewZ = viewPosition.z;\n        float intensity\t= distance(worldPosition.xyz, spotPosition) / attenuation;\n        intensity\t= 1.0 - clamp(intensity, 0.0, 1.0);\n        vIntensity = intensity;        \n        // set gl_Position\n        gl_Position\t= projectionMatrix * viewPosition;\n\n      }`,\n      fragmentShader:\n      /* glsl */\n      `\n      #include <packing>\n\n      varying vec3 vNormal;\n      varying vec3 vWorldPosition;\n      uniform vec3 lightColor;\n      uniform vec3 spotPosition;\n      uniform float attenuation;\n      uniform float anglePower;\n      uniform sampler2D depth;\n      uniform vec2 resolution;\n      uniform float cameraNear;\n      uniform float cameraFar;\n      varying float vViewZ;\n      varying float vIntensity;\n      uniform float opacity;\n\n      float readDepth( sampler2D depthSampler, vec2 coord ) {\n        float fragCoordZ = texture2D( depthSampler, coord ).x;\n        float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n        return viewZ;\n      }\n\n      void main() {\n        float d = 1.0;\n        bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n        if (isSoft) {\n          vec2 sUv = gl_FragCoord.xy / resolution;\n          d = readDepth(depth, sUv);\n        }\n        float intensity = vIntensity;\n        vec3 normal\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n        float angleIntensity\t= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );\n        intensity\t*= angleIntensity;\n        // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n        if (isSoft) {\n          intensity\t*= smoothstep(0., 1., vViewZ - d);\n        }\n        gl_FragColor = vec4(lightColor, intensity * opacity);\n\n        #include <tonemapping_fragment>\n\t      #include <${parseInt(THREE.REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n      }`\n    });\n  }\n\n}\n\nexport { SpotLightMaterial };\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,MAAMC,iBAAiB,SAASD,KAAK,CAACE,cAAc,CAAC;EACnDC,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC;MACJC,QAAQ,EAAE;QACRC,KAAK,EAAE;UACLC,KAAK,EAAE;QACT,CAAC;QACDC,OAAO,EAAE;UACPD,KAAK,EAAE;QACT,CAAC;QACDE,WAAW,EAAE;UACXF,KAAK,EAAE;QACT,CAAC;QACDG,UAAU,EAAE;UACVH,KAAK,EAAE;QACT,CAAC;QACDI,YAAY,EAAE;UACZJ,KAAK,EAAE,IAAIN,KAAK,CAACW,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;QAClC,CAAC;QACDC,UAAU,EAAE;UACVN,KAAK,EAAE,IAAIN,KAAK,CAACa,KAAK,CAAC,OAAO;QAChC,CAAC;QACDC,UAAU,EAAE;UACVR,KAAK,EAAE;QACT,CAAC;QACDS,SAAS,EAAE;UACTT,KAAK,EAAE;QACT,CAAC;QACDU,UAAU,EAAE;UACVV,KAAK,EAAE,IAAIN,KAAK,CAACiB,OAAO,CAAC,CAAC,EAAE,CAAC;QAC/B;MACF,CAAC;MACDC,WAAW,EAAE,IAAI;MACjBC,UAAU,EAAE,KAAK;MACjBC,YAAY,EACZ;MACC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;MACFC,cAAc,EACd;MACC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmBC,QAAQ,CAACtB,KAAK,CAACuB,QAAQ,CAACC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,IAAI,GAAG,GAAG,qBAAqB,GAAG,oBAAqB;AACtH;IACI,CAAC,CAAC;EACJ;AAEF;AAEA,SAASvB,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}