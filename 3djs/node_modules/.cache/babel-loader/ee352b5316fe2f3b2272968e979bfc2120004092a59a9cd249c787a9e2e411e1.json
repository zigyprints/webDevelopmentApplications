{"ast":null,"code":"import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, UniformsUtils, UniformsLib, REVISION, ShaderMaterial } from \"three\";\nclass Water extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isWater = true;\n    const scope = this;\n    const textureWidth = options.textureWidth !== void 0 ? options.textureWidth : 512;\n    const textureHeight = options.textureHeight !== void 0 ? options.textureHeight : 512;\n    const clipBias = options.clipBias !== void 0 ? options.clipBias : 0;\n    const alpha = options.alpha !== void 0 ? options.alpha : 1;\n    const time = options.time !== void 0 ? options.time : 0;\n    const normalSampler = options.waterNormals !== void 0 ? options.waterNormals : null;\n    const sunDirection = options.sunDirection !== void 0 ? options.sunDirection : new Vector3(0.70707, 0.70707, 0);\n    const sunColor = new Color(options.sunColor !== void 0 ? options.sunColor : 16777215);\n    const waterColor = new Color(options.waterColor !== void 0 ? options.waterColor : 8355711);\n    const eye = options.eye !== void 0 ? options.eye : new Vector3(0, 0, 0);\n    const distortionScale = options.distortionScale !== void 0 ? options.distortionScale : 20;\n    const side = options.side !== void 0 ? options.side : FrontSide;\n    const fog = options.fog !== void 0 ? options.fog : false;\n    const mirrorPlane = new Plane();\n    const normal = new Vector3();\n    const mirrorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const mirrorCamera = new PerspectiveCamera();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], UniformsLib[\"lights\"], {\n        normalSampler: {\n          value: null\n        },\n        mirrorSampler: {\n          value: null\n        },\n        alpha: {\n          value: 1\n        },\n        time: {\n          value: 0\n        },\n        size: {\n          value: 1\n        },\n        distortionScale: {\n          value: 20\n        },\n        textureMatrix: {\n          value: new Matrix4()\n        },\n        sunColor: {\n          value: new Color(8355711)\n        },\n        sunDirection: {\n          value: new Vector3(0.70707, 0.70707, 0)\n        },\n        eye: {\n          value: new Vector3()\n        },\n        waterColor: {\n          value: new Color(5592405)\n        }\n      }]),\n      vertexShader: /* glsl */\n      `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n      fragmentShader: /* glsl */\n      `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\t\t\t\t\t#include <fog_fragment>\t\n\t\t\t\t}`\n    };\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side,\n      fog\n    });\n    material.uniforms[\"mirrorSampler\"].value = renderTarget.texture;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    material.uniforms[\"alpha\"].value = alpha;\n    material.uniforms[\"time\"].value = time;\n    material.uniforms[\"normalSampler\"].value = normalSampler;\n    material.uniforms[\"sunColor\"].value = sunColor;\n    material.uniforms[\"waterColor\"].value = waterColor;\n    material.uniforms[\"sunDirection\"].value = sunDirection;\n    material.uniforms[\"distortionScale\"].value = distortionScale;\n    material.uniforms[\"eye\"].value = eye;\n    scope.material = material;\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far;\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse);\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      const projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld);\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n    };\n  }\n}\nexport { Water };","map":{"version":3,"names":["Mesh","Vector3","Color","FrontSide","Plane","Matrix4","Vector4","PerspectiveCamera","WebGLRenderTarget","UniformsUtils","UniformsLib","REVISION","ShaderMaterial","Water","constructor","geometry","options","isWater","scope","textureWidth","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","sunColor","waterColor","eye","distortionScale","side","fog","mirrorPlane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","mirrorCamera","renderTarget","mirrorShader","uniforms","merge","value","mirrorSampler","size","vertexShader","fragmentShader","parseInt","replace","material","clone","lights","texture","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/objects/Water.js"],"sourcesContent":["import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, UniformsUtils, UniformsLib, REVISION, ShaderMaterial } from \"three\";\nclass Water extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isWater = true;\n    const scope = this;\n    const textureWidth = options.textureWidth !== void 0 ? options.textureWidth : 512;\n    const textureHeight = options.textureHeight !== void 0 ? options.textureHeight : 512;\n    const clipBias = options.clipBias !== void 0 ? options.clipBias : 0;\n    const alpha = options.alpha !== void 0 ? options.alpha : 1;\n    const time = options.time !== void 0 ? options.time : 0;\n    const normalSampler = options.waterNormals !== void 0 ? options.waterNormals : null;\n    const sunDirection = options.sunDirection !== void 0 ? options.sunDirection : new Vector3(0.70707, 0.70707, 0);\n    const sunColor = new Color(options.sunColor !== void 0 ? options.sunColor : 16777215);\n    const waterColor = new Color(options.waterColor !== void 0 ? options.waterColor : 8355711);\n    const eye = options.eye !== void 0 ? options.eye : new Vector3(0, 0, 0);\n    const distortionScale = options.distortionScale !== void 0 ? options.distortionScale : 20;\n    const side = options.side !== void 0 ? options.side : FrontSide;\n    const fog = options.fog !== void 0 ? options.fog : false;\n    const mirrorPlane = new Plane();\n    const normal = new Vector3();\n    const mirrorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const mirrorCamera = new PerspectiveCamera();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([\n        UniformsLib[\"fog\"],\n        UniformsLib[\"lights\"],\n        {\n          normalSampler: { value: null },\n          mirrorSampler: { value: null },\n          alpha: { value: 1 },\n          time: { value: 0 },\n          size: { value: 1 },\n          distortionScale: { value: 20 },\n          textureMatrix: { value: new Matrix4() },\n          sunColor: { value: new Color(8355711) },\n          sunDirection: { value: new Vector3(0.70707, 0.70707, 0) },\n          eye: { value: new Vector3() },\n          waterColor: { value: new Color(5592405) }\n        }\n      ]),\n      vertexShader: (\n        /* glsl */\n        `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\t\t\t\t\t#include <fog_fragment>\t\n\t\t\t\t}`\n      )\n    };\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side,\n      fog\n    });\n    material.uniforms[\"mirrorSampler\"].value = renderTarget.texture;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    material.uniforms[\"alpha\"].value = alpha;\n    material.uniforms[\"time\"].value = time;\n    material.uniforms[\"normalSampler\"].value = normalSampler;\n    material.uniforms[\"sunColor\"].value = sunColor;\n    material.uniforms[\"waterColor\"].value = waterColor;\n    material.uniforms[\"sunDirection\"].value = sunDirection;\n    material.uniforms[\"distortionScale\"].value = distortionScale;\n    material.uniforms[\"eye\"].value = eye;\n    scope.material = material;\n    scope.onBeforeRender = function(renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0)\n        return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far;\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse);\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      const projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld);\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false)\n        renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n    };\n  }\n}\nexport {\n  Water\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}