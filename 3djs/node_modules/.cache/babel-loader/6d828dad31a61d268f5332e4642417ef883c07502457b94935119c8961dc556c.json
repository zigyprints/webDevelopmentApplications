{"ast":null,"code":"import { Vector3, BoxGeometry } from \"three\";\nconst tempNormal = /* @__PURE__ */new Vector3();\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  const totArcLength = 2 * Math.PI * radius / 4;\n  const centerLength = Math.max(sideLength - 2 * radius, 0);\n  const halfArc = Math.PI / 4;\n  tempNormal.copy(normal);\n  tempNormal[projectionAxis] = 0;\n  tempNormal.normalize();\n  const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength);\n  const arcAngleRatio = 1 - tempNormal.angleTo(faceDirVector) / halfArc;\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    const lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1 - arcAngleRatio);\n  }\n}\nclass RoundedBoxGeometry extends BoxGeometry {\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\n    segments = segments * 2 + 1;\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    super(1, 1, 1, segments, segments, segments);\n    if (segments === 1) return;\n    const geometry2 = this.toNonIndexed();\n    this.index = null;\n    this.attributes.position = geometry2.attributes.position;\n    this.attributes.normal = geometry2.attributes.normal;\n    this.attributes.uv = geometry2.attributes.uv;\n    const position = new Vector3();\n    const normal = new Vector3();\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    const positions = this.attributes.position.array;\n    const normals = this.attributes.normal.array;\n    const uvs = this.attributes.uv.array;\n    const faceTris = positions.length / 6;\n    const faceDirVector = new Vector3();\n    const halfSegmentSize = 0.5 / segments;\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      const side = Math.floor(i / faceTris);\n      switch (side) {\n        case 0:\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, \"z\", \"y\", radius, depth);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"z\", radius, height);\n          break;\n        case 1:\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"z\", \"y\", radius, depth);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"z\", radius, height);\n          break;\n        case 2:\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"z\", radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, \"z\", \"x\", radius, depth);\n          break;\n        case 3:\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"z\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"z\", \"x\", radius, depth);\n          break;\n        case 4:\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"y\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"x\", radius, height);\n          break;\n        case 5:\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, \"x\", \"y\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"x\", radius, height);\n          break;\n      }\n    }\n  }\n}\nexport { RoundedBoxGeometry };","map":{"version":3,"names":["Vector3","BoxGeometry","tempNormal","getUv","faceDirVector","normal","uvAxis","projectionAxis","radius","sideLength","totArcLength","Math","PI","centerLength","max","halfArc","copy","normalize","arcUvRatio","arcAngleRatio","angleTo","sign","lenUv","RoundedBoxGeometry","constructor","width","height","depth","segments","min","geometry2","toNonIndexed","index","attributes","position","uv","box","divideScalar","subScalar","positions","array","normals","uvs","faceTris","length","halfSegmentSize","i","j","fromArray","x","y","z","side","floor","set"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/geometries/RoundedBoxGeometry.js"],"sourcesContent":["import { Vector3, BoxGeometry } from \"three\";\nconst tempNormal = /* @__PURE__ */ new Vector3();\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  const totArcLength = 2 * Math.PI * radius / 4;\n  const centerLength = Math.max(sideLength - 2 * radius, 0);\n  const halfArc = Math.PI / 4;\n  tempNormal.copy(normal);\n  tempNormal[projectionAxis] = 0;\n  tempNormal.normalize();\n  const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength);\n  const arcAngleRatio = 1 - tempNormal.angleTo(faceDirVector) / halfArc;\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    const lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1 - arcAngleRatio);\n  }\n}\nclass RoundedBoxGeometry extends BoxGeometry {\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\n    segments = segments * 2 + 1;\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    super(1, 1, 1, segments, segments, segments);\n    if (segments === 1)\n      return;\n    const geometry2 = this.toNonIndexed();\n    this.index = null;\n    this.attributes.position = geometry2.attributes.position;\n    this.attributes.normal = geometry2.attributes.normal;\n    this.attributes.uv = geometry2.attributes.uv;\n    const position = new Vector3();\n    const normal = new Vector3();\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    const positions = this.attributes.position.array;\n    const normals = this.attributes.normal.array;\n    const uvs = this.attributes.uv.array;\n    const faceTris = positions.length / 6;\n    const faceDirVector = new Vector3();\n    const halfSegmentSize = 0.5 / segments;\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      const side = Math.floor(i / faceTris);\n      switch (side) {\n        case 0:\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, \"z\", \"y\", radius, depth);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"z\", radius, height);\n          break;\n        case 1:\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"z\", \"y\", radius, depth);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"z\", radius, height);\n          break;\n        case 2:\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"z\", radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, \"z\", \"x\", radius, depth);\n          break;\n        case 3:\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"z\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"z\", \"x\", radius, depth);\n          break;\n        case 4:\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"y\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"x\", radius, height);\n          break;\n        case 5:\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, \"x\", \"y\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"x\", radius, height);\n          break;\n      }\n    }\n  }\n}\nexport {\n  RoundedBoxGeometry\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}