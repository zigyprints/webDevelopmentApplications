{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from \"three\";\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\nconst initSplineTexture = (numberOfCurves = 1) => {\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\nconst updateSplineTexture = (texture, splineCurve, offset = 0) => {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    const rowIndex = i % TEXTURE_WIDTH;\n    let pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n  texture.needsUpdate = true;\n};\nconst setTextureValue = (texture, index, x, y, z, o) => {\n  const image = texture.image;\n  const {\n    data\n  } = image;\n  const i = CHANNELS * TEXTURE_WIDTH * o;\n  data[index * CHANNELS + i + 0] = x;\n  data[index * CHANNELS + i + 1] = y;\n  data[index * CHANNELS + i + 2] = z;\n  data[index * CHANNELS + i + 3] = 1;\n};\nconst getUniforms = splineTexture => ({\n  spineTexture: {\n    value: splineTexture\n  },\n  pathOffset: {\n    type: \"f\",\n    value: 0\n  },\n  // time of path curve\n  pathSegment: {\n    type: \"f\",\n    value: 1\n  },\n  // fractional length of path\n  spineOffset: {\n    type: \"f\",\n    value: 161\n  },\n  spineLength: {\n    type: \"f\",\n    value: 400\n  },\n  flow: {\n    type: \"i\",\n    value: 1\n  }\n});\nfunction modifyShader(material, uniforms, numberOfCurves = 1) {\n  if (material.__ok) return;\n  material.__ok = true;\n  material.onBeforeCompile = shader => {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    const vertexShader = /* glsl */\n    `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`.replace(\"#include <beginnormal_vertex>\", \"\").replace(\"#include <defaultnormal_vertex>\", \"\").replace(\"#include <begin_vertex>\", \"\").replace(/void\\s*main\\s*\\(\\)\\s*\\{/, /* glsl */\n    `\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`).replace(\"#include <project_vertex>\", /* glsl */\n    `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`);\n    shader.vertexShader = vertexShader;\n  };\n}\nclass Flow {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh, numberOfCurves = 1) {\n    __publicField(this, \"curveArray\");\n    __publicField(this, \"curveLengthArray\");\n    __publicField(this, \"object3D\");\n    __publicField(this, \"splineTexure\");\n    __publicField(this, \"uniforms\");\n    const obj3D = mesh.clone();\n    const splineTexure = initSplineTexture(numberOfCurves);\n    const uniforms = getUniforms(splineTexure);\n    obj3D.traverse(child => {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n  updateCurve(index, curve) {\n    if (index >= this.curveArray.length) throw Error(\"Index out of range for Flow\");\n    const curveLength = curve.getLength();\n    this.uniforms.spineLength.value = curveLength;\n    this.curveLengthArray[index] = curveLength;\n    this.curveArray[index] = curve;\n    updateSplineTexture(this.splineTexure, curve, index);\n  }\n  moveAlongCurve(amount) {\n    this.uniforms.pathOffset.value += amount;\n  }\n}\nconst matrix = /* @__PURE__ */new Matrix4();\nclass InstancedFlow extends Flow {\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count, curveCount, geometry, material) {\n    const mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    mesh.frustumCulled = false;\n    super(mesh, curveCount);\n    __publicField(this, \"offsets\");\n    __publicField(this, \"whichCurve\");\n    this.offsets = new Array(count).fill(0);\n    this.whichCurve = new Array(count).fill(0);\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n  writeChanges(index) {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n    this.object3D.setMatrixAt(index, matrix);\n    this.object3D.instanceMatrix.needsUpdate = true;\n  }\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n  moveIndividualAlongCurve(index, offset) {\n    this.offsets[index] += offset;\n    this.writeChanges(index);\n  }\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n  setCurve(index, curveNo) {\n    if (isNaN(curveNo)) throw Error(\"curve index being set is Not a Number (NaN)\");\n    this.whichCurve[index] = curveNo;\n    this.writeChanges(index);\n  }\n}\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","DataTexture","RGBAFormat","FloatType","RepeatWrapping","NearestFilter","Mesh","InstancedMesh","Matrix4","DynamicDrawUsage","CHANNELS","TEXTURE_WIDTH","TEXTURE_HEIGHT","initSplineTexture","numberOfCurves","dataArray","Float32Array","dataTexture","wrapS","wrapT","magFilter","needsUpdate","updateSplineTexture","texture","splineCurve","offset","numberOfPoints","Math","floor","arcLengthDivisions","updateArcLengths","points","getSpacedPoints","frenetFrames","computeFrenetFrames","i","rowOffset","rowIndex","pt","setTextureValue","x","y","z","tangents","normals","binormals","index","o","image","data","getUniforms","splineTexture","spineTexture","pathOffset","type","pathSegment","spineOffset","spineLength","flow","modifyShader","material","uniforms","__ok","onBeforeCompile","shader","__modified","assign","vertexShader","replace","Flow","constructor","mesh","obj3D","clone","splineTexure","traverse","child","curveArray","Array","curveLengthArray","object3D","updateCurve","curve","length","Error","curveLength","getLength","moveAlongCurve","amount","matrix","InstancedFlow","count","curveCount","geometry","instanceMatrix","setUsage","frustumCulled","offsets","fill","whichCurve","writeChanges","makeTranslation","setMatrixAt","moveIndividualAlongCurve","setCurve","curveNo","isNaN"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/modifiers/CurveModifier.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from \"three\";\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\nconst initSplineTexture = (numberOfCurves = 1) => {\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\nconst updateSplineTexture = (texture, splineCurve, offset = 0) => {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    const rowIndex = i % TEXTURE_WIDTH;\n    let pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n  texture.needsUpdate = true;\n};\nconst setTextureValue = (texture, index, x, y, z, o) => {\n  const image = texture.image;\n  const { data } = image;\n  const i = CHANNELS * TEXTURE_WIDTH * o;\n  data[index * CHANNELS + i + 0] = x;\n  data[index * CHANNELS + i + 1] = y;\n  data[index * CHANNELS + i + 2] = z;\n  data[index * CHANNELS + i + 3] = 1;\n};\nconst getUniforms = (splineTexture) => ({\n  spineTexture: { value: splineTexture },\n  pathOffset: { type: \"f\", value: 0 },\n  // time of path curve\n  pathSegment: { type: \"f\", value: 1 },\n  // fractional length of path\n  spineOffset: { type: \"f\", value: 161 },\n  spineLength: { type: \"f\", value: 400 },\n  flow: { type: \"i\", value: 1 }\n});\nfunction modifyShader(material, uniforms, numberOfCurves = 1) {\n  if (material.__ok)\n    return;\n  material.__ok = true;\n  material.onBeforeCompile = (shader) => {\n    if (shader.__modified)\n      return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    const vertexShader = (\n      /* glsl */\n      `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`.replace(\"#include <beginnormal_vertex>\", \"\").replace(\"#include <defaultnormal_vertex>\", \"\").replace(\"#include <begin_vertex>\", \"\").replace(\n        /void\\s*main\\s*\\(\\)\\s*\\{/,\n        /* glsl */\n        `\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`\n      ).replace(\n        \"#include <project_vertex>\",\n        /* glsl */\n        `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`\n      )\n    );\n    shader.vertexShader = vertexShader;\n  };\n}\nclass Flow {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh, numberOfCurves = 1) {\n    __publicField(this, \"curveArray\");\n    __publicField(this, \"curveLengthArray\");\n    __publicField(this, \"object3D\");\n    __publicField(this, \"splineTexure\");\n    __publicField(this, \"uniforms\");\n    const obj3D = mesh.clone();\n    const splineTexure = initSplineTexture(numberOfCurves);\n    const uniforms = getUniforms(splineTexure);\n    obj3D.traverse((child) => {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n  updateCurve(index, curve) {\n    if (index >= this.curveArray.length)\n      throw Error(\"Index out of range for Flow\");\n    const curveLength = curve.getLength();\n    this.uniforms.spineLength.value = curveLength;\n    this.curveLengthArray[index] = curveLength;\n    this.curveArray[index] = curve;\n    updateSplineTexture(this.splineTexure, curve, index);\n  }\n  moveAlongCurve(amount) {\n    this.uniforms.pathOffset.value += amount;\n  }\n}\nconst matrix = /* @__PURE__ */ new Matrix4();\nclass InstancedFlow extends Flow {\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count, curveCount, geometry, material) {\n    const mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    mesh.frustumCulled = false;\n    super(mesh, curveCount);\n    __publicField(this, \"offsets\");\n    __publicField(this, \"whichCurve\");\n    this.offsets = new Array(count).fill(0);\n    this.whichCurve = new Array(count).fill(0);\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n  writeChanges(index) {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n    this.object3D.setMatrixAt(index, matrix);\n    this.object3D.instanceMatrix.needsUpdate = true;\n  }\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n  moveIndividualAlongCurve(index, offset) {\n    this.offsets[index] += offset;\n    this.writeChanges(index);\n  }\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n  setCurve(index, curveNo) {\n    if (isNaN(curveNo))\n      throw Error(\"curve index being set is Not a Number (NaN)\");\n    this.whichCurve[index] = curveNo;\n    this.writeChanges(index);\n  }\n}\nexport {\n  Flow,\n  InstancedFlow,\n  getUniforms,\n  initSplineTexture,\n  modifyShader,\n  updateSplineTexture\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}