{"ast":null,"code":"import { Matrix4, Box3 } from 'three';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/******************************************************/\n/* This file is generated from \"bvhcast.template.js\". */\n/******************************************************/\n\nconst tempMatrix = new Matrix4();\nconst aabb = /* @__PURE__ */new Box3();\nconst aabb2 = /* @__PURE__ */new Box3();\nfunction bvhcast_indirect(bvh, otherBvh, matrixToLocal, callbacks) {\n  // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n  // than an approach that walks down the tree (see bvhcast.js file for more info).\n\n  let {\n    intersectsRanges,\n    intersectsTriangles\n  } = callbacks;\n  const indexAttr = bvh.geometry.index;\n  const positionAttr = bvh.geometry.attributes.position;\n  const otherIndexAttr = otherBvh.geometry.index;\n  const otherPositionAttr = otherBvh.geometry.attributes.position;\n  tempMatrix.copy(matrixToLocal).invert();\n  const triangle = ExtendedTrianglePool.getPrimitive();\n  const triangle2 = ExtendedTrianglePool.getPrimitive();\n  if (intersectsTriangles) {\n    const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {\n      for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n        const ti2 = otherBvh.resolveTriangleIndex(i2);\n        setTriangle(triangle2, ti2 * 3, otherIndexAttr, otherPositionAttr);\n        triangle2.a.applyMatrix4(matrixToLocal);\n        triangle2.b.applyMatrix4(matrixToLocal);\n        triangle2.c.applyMatrix4(matrixToLocal);\n        triangle2.needsUpdate = true;\n        for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n          const ti1 = bvh.resolveTriangleIndex(i1);\n          setTriangle(triangle, ti1 * 3, indexAttr, positionAttr);\n          triangle.needsUpdate = true;\n          if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    if (intersectsRanges) {\n      const originalIntersectsRanges = intersectsRanges;\n      intersectsRanges = function (offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n        if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n          return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n        }\n        return true;\n      };\n    } else {\n      intersectsRanges = iterateOverDoubleTriangles;\n    }\n  }\n  otherBvh.getBoundingBox(aabb2);\n  aabb2.applyMatrix4(matrixToLocal);\n  const result = bvh.shapecast({\n    intersectsBounds: box => aabb2.intersectsBox(box),\n    intersectsRange: (offset1, count1, contained, depth1, nodeIndex1, box) => {\n      aabb.copy(box);\n      aabb.applyMatrix4(tempMatrix);\n      return otherBvh.shapecast({\n        intersectsBounds: box => aabb.intersectsBox(box),\n        intersectsRange: (offset2, count2, contained, depth2, nodeIndex2) => {\n          return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n        }\n      });\n    }\n  });\n  ExtendedTrianglePool.releasePrimitive(triangle);\n  ExtendedTrianglePool.releasePrimitive(triangle2);\n  return result;\n}\nexport { bvhcast_indirect };","map":{"version":3,"names":["Matrix4","Box3","setTriangle","ExtendedTrianglePool","tempMatrix","aabb","aabb2","bvhcast_indirect","bvh","otherBvh","matrixToLocal","callbacks","intersectsRanges","intersectsTriangles","indexAttr","geometry","index","positionAttr","attributes","position","otherIndexAttr","otherPositionAttr","copy","invert","triangle","getPrimitive","triangle2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","index2","i2","l2","ti2","resolveTriangleIndex","a","applyMatrix4","b","c","needsUpdate","i1","l1","ti1","originalIntersectsRanges","getBoundingBox","result","shapecast","intersectsBounds","box","intersectsBox","intersectsRange","contained","nodeIndex1","nodeIndex2","releasePrimitive"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-mesh-bvh/src/core/cast/bvhcast_indirect.generated.js"],"sourcesContent":["import { Matrix4, Box3 } from 'three';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/******************************************************/\n/* This file is generated from \"bvhcast.template.js\". */\n/******************************************************/\n\nconst tempMatrix = new Matrix4();\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nfunction bvhcast_indirect( bvh, otherBvh, matrixToLocal, callbacks ) {\n\n\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\tlet {\n\t\tintersectsRanges,\n\t\tintersectsTriangles,\n\t} = callbacks;\n\n\tconst indexAttr = bvh.geometry.index;\n\tconst positionAttr = bvh.geometry.attributes.position;\n\n\tconst otherIndexAttr = otherBvh.geometry.index;\n\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\ttempMatrix.copy( matrixToLocal ).invert();\n\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tif ( intersectsTriangles ) {\n\n\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, otherIndexAttr, otherPositionAttr );\n\n\n\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\tconst ti1 = bvh.resolveTriangleIndex( i1 );\n\t\t\t\t\tsetTriangle( triangle, ti1 * 3, indexAttr, positionAttr );\n\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\tif ( intersectsRanges ) {\n\n\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t}\n\n\t}\n\n\totherBvh.getBoundingBox( aabb2 );\n\taabb2.applyMatrix4( matrixToLocal );\n\tconst result = bvh.shapecast( {\n\n\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\taabb.copy( box );\n\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t},\n\n\t\t\t} );\n\n\t\t}\n\n\t} );\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\treturn result;\n\n}\n\nexport { bvhcast_indirect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}