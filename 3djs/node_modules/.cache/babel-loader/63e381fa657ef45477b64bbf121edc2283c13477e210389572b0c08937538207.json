{"ast":null,"code":"import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n        return null;\n      }\n      if (morphAttributes[name] === void 0) morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach(geom => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = attributes => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach(attr => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n      return null;\n    }\n    if (itemSize === void 0) itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n      return null;\n    }\n    if (normalized === void 0) normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach(attr => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = attributes => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n    // @ts-ignore\n    material2.morphTargets && morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0) continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport { computeMorphedAttributes, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeVertices, toCreasedNormals, toTrianglesDrawMode };","map":{"version":3,"names":["BufferGeometry","BufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","Vector3","Float32BufferAttribute","getWithKey","mergeBufferGeometries","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","attributes","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","forEach","geom","i","attributesCount","console","error","name","has","push","size","userData","mergedUserData","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","mergeBufferAttributes","setAttribute","numMorphTargets","length","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attr","array","constructor","set","interleaveAttributes","stride","l","attribute","interleavedBuffer","res","getters","setters","iba","c","k","get","estimateBytesUsed","geometry","mem","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","buffer2","morphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","object2","material2","morphTargetsRelative2","a2","b2","c2","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","i2","il2","influence","morph","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","material","a","b","positionAttribute","morphPosition","normalAttribute","normal","morphNormal","groups","drawRange","il","jl","group","groupMaterial","start","end","modifiedPosition","Float32Array","modifiedNormal","isArray","materialIndex","min","morphedPositionAttribute","morphedNormalAttribute","toCreasedNormals","creaseAngle","PI","creaseDot","cos","hashMultiplier","verts","tempVec1","tempVec2","tempNorm","tempNorm2","hashVertex","v","resultGeometry","toNonIndexed","posAttr","vertexMap","i3","subVectors","crossVectors","normalize","n","vert","normalArray","normAttr","otherNormals","lk","otherNorm","dot","setXYZ"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/utils/BufferGeometryUtils.js"],"sourcesContent":["import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport {\n  computeMorphedAttributes,\n  estimateBytesUsed,\n  interleaveAttributes,\n  mergeBufferAttributes,\n  mergeBufferGeometries,\n  mergeVertices,\n  toCreasedNormals,\n  toTrianglesDrawMode\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}