{"ast":null,"code":"import { Matrix4, Object3D, Vector3, EventDispatcher, BufferGeometry, Float32BufferAttribute, MathUtils, Matrix3, Color, Vector2, Box3, Sphere, BufferAttribute } from \"three\";\nconst _m1 = /* @__PURE__ */new Matrix4();\nconst _obj = /* @__PURE__ */new Object3D();\nconst _offset = /* @__PURE__ */new Vector3();\nclass Geometry extends EventDispatcher {\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry();\n    const geometry = object.geometry;\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n      buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n      buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n        buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n      }\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry();\n    }\n    return buffergeometry;\n  }\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = \"\";\n    this.type = \"Geometry\";\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n  rotateX(angle) {\n    _m1.makeRotationX(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateY(angle) {\n    _m1.makeRotationY(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateZ(angle) {\n    _m1.makeRotationZ(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  translate(x, y, z) {\n    _m1.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  scale(x, y, z) {\n    _m1.makeScale(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : void 0;\n    const attributes = geometry.attributes;\n    if (attributes.position === void 0) {\n      console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n      return this;\n    }\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== void 0) this.faceVertexUvs[1] = [];\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n      if (color !== void 0) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === void 0 ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === void 0 ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n      if (uv !== void 0) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n      if (uv2 !== void 0) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n    const groups = geometry.groups;\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== void 0) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== void 0) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n    this.computeFaceNormals();\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n  computeFaceNormals() {\n    const cb = new Vector3(),\n      ab = new Vector3();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n    if (areaWeighted) {\n      const cb = new Vector3(),\n        ab = new Vector3();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeMorphNormals() {\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    }\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n      const morphNormals = this.morphNormals[i];\n      tmpGeo.vertices = this.morphTargets[i].vertices;\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n      return;\n    }\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n      vertices1 = this.vertices,\n      vertices2 = geometry.vertices,\n      faces1 = this.faces,\n      faces2 = geometry.faces,\n      colors1 = this.colors,\n      colors2 = geometry.colors;\n    if (matrix !== void 0) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    }\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== void 0) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    }\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    }\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n        faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n      if (normalMatrix !== void 0) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n        if (normalMatrix !== void 0) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n        faceCopy.vertexNormals.push(normal);\n      }\n      faceCopy.color.copy(face.color);\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    }\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0) this.faceVertexUvs[i] = [];\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n          uvsCopy = [];\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n      return;\n    }\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {};\n    const unique = [],\n      changes = [];\n    const precision = Math.pow(10, precisionPoints);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n      if (verticesMap[key] === void 0) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        changes[i] = changes[verticesMap[key]];\n      }\n    }\n    const faceIndicesToRemove = [];\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c];\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    }\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n  setFromPoints(points) {\n    this.vertices = [];\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n    return this;\n  }\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length;\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    }\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n    faces.sort(materialIndexSort);\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: \"Geometry\",\n        generator: \"Geometry.toJSON\"\n      }\n    };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \"\") data.name = this.name;\n    if (this.parameters !== void 0) {\n      const parameters = this.parameters;\n      for (let key in parameters) {\n        if (parameters[key] !== void 0) data[key] = parameters[key];\n      }\n      return data;\n    }\n    const vertices = [];\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false;\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0);\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n      if (normalsHash[hash] !== void 0) {\n        return normalsHash[hash];\n      }\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n      if (colorsHash[hash] !== void 0) {\n        return colorsHash[hash];\n      }\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n      if (uvsHash[hash] !== void 0) {\n        return uvsHash[hash];\n      }\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs];\n    data.data.faces = faces;\n    return data;\n  }\n  clone() {\n    return new Geometry().copy(this);\n  }\n  copy(source) {\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.name = source.name;\n    const vertices = source.vertices;\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    }\n    const colors = source.colors;\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    }\n    const faces = source.faces;\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    }\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0) {\n        this.faceVertexUvs[i] = [];\n      }\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n          uvsCopy = [];\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n    const morphTargets = source.morphTargets;\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name;\n      if (morphTargets[i].vertices !== void 0) {\n        morphTarget.vertices = [];\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      }\n      if (morphTargets[i].normals !== void 0) {\n        morphTarget.normals = [];\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n      this.morphTargets.push(morphTarget);\n    }\n    const morphNormals = source.morphNormals;\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {};\n      if (morphNormals[i].vertexNormals !== void 0) {\n        morphNormal.vertexNormals = [];\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      }\n      if (morphNormals[i].faceNormals !== void 0) {\n        morphNormal.faceNormals = [];\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n      this.morphNormals.push(morphNormal);\n    }\n    const skinWeights = source.skinWeights;\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    }\n    const skinIndices = source.skinIndices;\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    }\n    const lineDistances = source.lineDistances;\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    }\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute(\"position\", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute(\"color\", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute(\"uv2\", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    }\n    buffergeometry.groups = geometry.groups;\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n      buffergeometry.morphAttributes[name] = array;\n    }\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n    }\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n    return buffergeometry;\n  }\n  computeTangents() {\n    console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n  }\n  computeLineDistances() {\n    console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\");\n  }\n  applyMatrix(matrix) {\n    console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: \"dispose\"\n    });\n  }\n}\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = void 0;\n    const faces = geometry.faces;\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n        if (group !== void 0) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n    if (group !== void 0) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n    this.groups = groups;\n  }\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.position = morphTargetsPosition;\n    }\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.normal = morphTargetsNormal;\n    }\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length;\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n    }\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n      const vertexColors = face.vertexColors;\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n        if (vertexUvs !== void 0) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n        if (vertexUvs !== void 0) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      }\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    return this;\n  }\n}\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n    return this;\n  }\n}\nexport { Face3, Geometry };","map":{"version":3,"names":["Matrix4","Object3D","Vector3","EventDispatcher","BufferGeometry","Float32BufferAttribute","MathUtils","Matrix3","Color","Vector2","Box3","Sphere","BufferAttribute","_m1","_obj","_offset","Geometry","createBufferGeometryFromObject","object","buffergeometry","geometry","isPoints","isLine","positions","vertices","length","colors","setAttribute","copyVector3sArray","copyColorsArray","lineDistances","copyArray","boundingSphere","clone","boundingBox","isMesh","toBufferGeometry","constructor","isGeometry","uuid","generateUUID","name","type","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","applyMatrix4","matrix","normalMatrix","getNormalMatrix","i","il","vertex","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","scope","index","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","addFace","a","b","c","materialIndex","vertexColors","Face3","groups","group","start","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","computeVertexNormals","areaWeighted","Array","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mergeMesh","mesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","toJSON","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","value","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","DirectGeometry","fromGeometry","Float32Array","copyVector2sArray","array","attribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","warn","dispose","dispatchEvent","computeGroups","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","morphNormalsLength","morphTargetsNormal","hasSkinIndices","hasSkinWeights","vertexUvs","isVector3","isArray","isColor"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/deprecated/Geometry.js"],"sourcesContent":["import { Matrix4, Object3D, Vector3, EventDispatcher, BufferGeometry, Float32BufferAttribute, MathUtils, Matrix3, Color, Vector2, Box3, Sphere, BufferAttribute } from \"three\";\nconst _m1 = /* @__PURE__ */ new Matrix4();\nconst _obj = /* @__PURE__ */ new Object3D();\nconst _offset = /* @__PURE__ */ new Vector3();\nclass Geometry extends EventDispatcher {\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry();\n    const geometry = object.geometry;\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n      buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n      buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n        buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n      }\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry();\n    }\n    return buffergeometry;\n  }\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = \"\";\n    this.type = \"Geometry\";\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n  rotateX(angle) {\n    _m1.makeRotationX(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateY(angle) {\n    _m1.makeRotationY(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateZ(angle) {\n    _m1.makeRotationZ(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  translate(x, y, z) {\n    _m1.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  scale(x, y, z) {\n    _m1.makeScale(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : void 0;\n    const attributes = geometry.attributes;\n    if (attributes.position === void 0) {\n      console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n      return this;\n    }\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== void 0)\n      this.faceVertexUvs[1] = [];\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n      if (color !== void 0) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === void 0 ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === void 0 ? [] : [\n        new Vector3().fromBufferAttribute(normal, a),\n        new Vector3().fromBufferAttribute(normal, b),\n        new Vector3().fromBufferAttribute(normal, c)\n      ];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n      if (uv !== void 0) {\n        scope.faceVertexUvs[0].push([\n          new Vector2().fromBufferAttribute(uv, a),\n          new Vector2().fromBufferAttribute(uv, b),\n          new Vector2().fromBufferAttribute(uv, c)\n        ]);\n      }\n      if (uv2 !== void 0) {\n        scope.faceVertexUvs[1].push([\n          new Vector2().fromBufferAttribute(uv2, a),\n          new Vector2().fromBufferAttribute(uv2, b),\n          new Vector2().fromBufferAttribute(uv2, c)\n        ]);\n      }\n    }\n    const groups = geometry.groups;\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== void 0) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== void 0) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n    this.computeFaceNormals();\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n  computeFaceNormals() {\n    const cb = new Vector3(), ab = new Vector3();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n    if (areaWeighted) {\n      const cb = new Vector3(), ab = new Vector3();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeMorphNormals() {\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n      if (!face.__originalVertexNormals)\n        face.__originalVertexNormals = [];\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    }\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n      const morphNormals = this.morphNormals[i];\n      tmpGeo.vertices = this.morphTargets[i].vertices;\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n      return;\n    }\n    let normalMatrix;\n    const vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;\n    if (matrix !== void 0) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    }\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== void 0)\n        vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    }\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    }\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n      if (normalMatrix !== void 0) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n        if (normalMatrix !== void 0) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n        faceCopy.vertexNormals.push(normal);\n      }\n      faceCopy.color.copy(face.color);\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    }\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0)\n        this.faceVertexUvs[i] = [];\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j], uvsCopy = [];\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n      return;\n    }\n    if (mesh.matrixAutoUpdate)\n      mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {};\n    const unique = [], changes = [];\n    const precision = Math.pow(10, precisionPoints);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n      if (verticesMap[key] === void 0) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        changes[i] = changes[verticesMap[key]];\n      }\n    }\n    const faceIndicesToRemove = [];\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c];\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    }\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n  setFromPoints(points) {\n    this.vertices = [];\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n    return this;\n  }\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length;\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    }\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n    faces.sort(materialIndexSort);\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length)\n      newUvs1 = [];\n    if (uvs2 && uvs2.length === length)\n      newUvs2 = [];\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1)\n        newUvs1.push(uvs1[id]);\n      if (newUvs2)\n        newUvs2.push(uvs2[id]);\n    }\n    if (newUvs1)\n      this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2)\n      this.faceVertexUvs[1] = newUvs2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: \"Geometry\",\n        generator: \"Geometry.toJSON\"\n      }\n    };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \"\")\n      data.name = this.name;\n    if (this.parameters !== void 0) {\n      const parameters = this.parameters;\n      for (let key in parameters) {\n        if (parameters[key] !== void 0)\n          data[key] = parameters[key];\n      }\n      return data;\n    }\n    const vertices = [];\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false;\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0);\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n      if (normalsHash[hash] !== void 0) {\n        return normalsHash[hash];\n      }\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n      if (colorsHash[hash] !== void 0) {\n        return colorsHash[hash];\n      }\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n      if (uvsHash[hash] !== void 0) {\n        return uvsHash[hash];\n      }\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0)\n      data.data.colors = colors;\n    if (uvs.length > 0)\n      data.data.uvs = [uvs];\n    data.data.faces = faces;\n    return data;\n  }\n  clone() {\n    return new Geometry().copy(this);\n  }\n  copy(source) {\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.name = source.name;\n    const vertices = source.vertices;\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    }\n    const colors = source.colors;\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    }\n    const faces = source.faces;\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    }\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0) {\n        this.faceVertexUvs[i] = [];\n      }\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j], uvsCopy = [];\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n    const morphTargets = source.morphTargets;\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name;\n      if (morphTargets[i].vertices !== void 0) {\n        morphTarget.vertices = [];\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      }\n      if (morphTargets[i].normals !== void 0) {\n        morphTarget.normals = [];\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n      this.morphTargets.push(morphTarget);\n    }\n    const morphNormals = source.morphNormals;\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {};\n      if (morphNormals[i].vertexNormals !== void 0) {\n        morphNormal.vertexNormals = [];\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      }\n      if (morphNormals[i].faceNormals !== void 0) {\n        morphNormal.faceNormals = [];\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n      this.morphNormals.push(morphNormal);\n    }\n    const skinWeights = source.skinWeights;\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    }\n    const skinIndices = source.skinIndices;\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    }\n    const lineDistances = source.lineDistances;\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    }\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute(\"position\", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute(\"color\", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute(\"uv2\", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    }\n    buffergeometry.groups = geometry.groups;\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n      buffergeometry.morphAttributes[name] = array;\n    }\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n    }\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n    return buffergeometry;\n  }\n  computeTangents() {\n    console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n  }\n  computeLineDistances() {\n    console.error(\n      \"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\"\n    );\n  }\n  applyMatrix(matrix) {\n    console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n}\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = void 0;\n    const faces = geometry.faces;\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n        if (group !== void 0) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n    if (group !== void 0) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n    this.groups = groups;\n  }\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.position = morphTargetsPosition;\n    }\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.normal = morphTargetsNormal;\n    }\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length;\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n    }\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n      const vertexColors = face.vertexColors;\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n        if (vertexUvs !== void 0) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n        if (vertexUvs !== void 0) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      }\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    return this;\n  }\n}\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n    return this;\n  }\n}\nexport {\n  Face3,\n  Geometry\n};\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,eAAe,EAAEC,cAAc,EAAEC,sBAAsB,EAAEC,SAAS,EAAEC,OAAO,EAAEC,KAAK,EAAEC,OAAO,EAAEC,IAAI,EAAEC,MAAM,EAAEC,eAAe,QAAQ,OAAO;AAC9K,MAAMC,GAAG,GAAG,eAAgB,IAAIb,OAAO,CAAC,CAAC;AACzC,MAAMc,IAAI,GAAG,eAAgB,IAAIb,QAAQ,CAAC,CAAC;AAC3C,MAAMc,OAAO,GAAG,eAAgB,IAAIb,OAAO,CAAC,CAAC;AAC7C,MAAMc,QAAQ,SAASb,eAAe,CAAC;EACrC,OAAOc,8BAA8BA,CAACC,MAAM,EAAE;IAC5C,IAAIC,cAAc,GAAG,IAAIf,cAAc,CAAC,CAAC;IACzC,MAAMgB,QAAQ,GAAGF,MAAM,CAACE,QAAQ;IAChC,IAAIF,MAAM,CAACG,QAAQ,IAAIH,MAAM,CAACI,MAAM,EAAE;MACpC,MAAMC,SAAS,GAAG,IAAIlB,sBAAsB,CAACe,QAAQ,CAACI,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;MAC7E,MAAMC,MAAM,GAAG,IAAIrB,sBAAsB,CAACe,QAAQ,CAACM,MAAM,CAACD,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;MACxEN,cAAc,CAACQ,YAAY,CAAC,UAAU,EAAEJ,SAAS,CAACK,iBAAiB,CAACR,QAAQ,CAACI,QAAQ,CAAC,CAAC;MACvFL,cAAc,CAACQ,YAAY,CAAC,OAAO,EAAED,MAAM,CAACG,eAAe,CAACT,QAAQ,CAACM,MAAM,CAAC,CAAC;MAC7E,IAAIN,QAAQ,CAACU,aAAa,IAAIV,QAAQ,CAACU,aAAa,CAACL,MAAM,KAAKL,QAAQ,CAACI,QAAQ,CAACC,MAAM,EAAE;QACxF,MAAMK,aAAa,GAAG,IAAIzB,sBAAsB,CAACe,QAAQ,CAACU,aAAa,CAACL,MAAM,EAAE,CAAC,CAAC;QAClFN,cAAc,CAACQ,YAAY,CAAC,cAAc,EAAEG,aAAa,CAACC,SAAS,CAACX,QAAQ,CAACU,aAAa,CAAC,CAAC;MAC9F;MACA,IAAIV,QAAQ,CAACY,cAAc,KAAK,IAAI,EAAE;QACpCb,cAAc,CAACa,cAAc,GAAGZ,QAAQ,CAACY,cAAc,CAACC,KAAK,CAAC,CAAC;MACjE;MACA,IAAIb,QAAQ,CAACc,WAAW,KAAK,IAAI,EAAE;QACjCf,cAAc,CAACe,WAAW,GAAGd,QAAQ,CAACc,WAAW,CAACD,KAAK,CAAC,CAAC;MAC3D;IACF,CAAC,MAAM,IAAIf,MAAM,CAACiB,MAAM,EAAE;MACxBhB,cAAc,GAAGC,QAAQ,CAACgB,gBAAgB,CAAC,CAAC;IAC9C;IACA,OAAOjB,cAAc;EACvB;EACAkB,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,IAAI,GAAGjC,SAAS,CAACkC,YAAY,CAAC,CAAC;IACpC,IAAI,CAACC,IAAI,GAAG,EAAE;IACd,IAAI,CAACC,IAAI,GAAG,UAAU;IACtB,IAAI,CAAClB,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACE,MAAM,GAAG,EAAE;IAChB,IAAI,CAACiB,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,aAAa,GAAG,CAAC,EAAE,CAAC;IACzB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAAClB,aAAa,GAAG,EAAE;IACvB,IAAI,CAACI,WAAW,GAAG,IAAI;IACvB,IAAI,CAACF,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACiB,kBAAkB,GAAG,KAAK;IAC/B,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B,IAAI,CAACC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACC,uBAAuB,GAAG,KAAK;IACpC,IAAI,CAACC,gBAAgB,GAAG,KAAK;EAC/B;EACAC,YAAYA,CAACC,MAAM,EAAE;IACnB,MAAMC,YAAY,GAAG,IAAInD,OAAO,CAAC,CAAC,CAACoD,eAAe,CAACF,MAAM,CAAC;IAC1D,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACrC,QAAQ,CAACC,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACtD,MAAME,MAAM,GAAG,IAAI,CAACtC,QAAQ,CAACoC,CAAC,CAAC;MAC/BE,MAAM,CAACN,YAAY,CAACC,MAAM,CAAC;IAC7B;IACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAClB,KAAK,CAAClB,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMG,IAAI,GAAG,IAAI,CAACpB,KAAK,CAACiB,CAAC,CAAC;MAC1BG,IAAI,CAACC,MAAM,CAACC,YAAY,CAACP,YAAY,CAAC,CAACQ,SAAS,CAAC,CAAC;MAClD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGL,IAAI,CAACM,aAAa,CAAC5C,MAAM,EAAE0C,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QAC3DJ,IAAI,CAACM,aAAa,CAACF,CAAC,CAAC,CAACF,YAAY,CAACP,YAAY,CAAC,CAACQ,SAAS,CAAC,CAAC;MAC9D;IACF;IACA,IAAI,IAAI,CAAChC,WAAW,KAAK,IAAI,EAAE;MAC7B,IAAI,CAACoC,kBAAkB,CAAC,CAAC;IAC3B;IACA,IAAI,IAAI,CAACtC,cAAc,KAAK,IAAI,EAAE;MAChC,IAAI,CAACuC,qBAAqB,CAAC,CAAC;IAC9B;IACA,IAAI,CAACrB,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACE,iBAAiB,GAAG,IAAI;IAC7B,OAAO,IAAI;EACb;EACAoB,OAAOA,CAACC,KAAK,EAAE;IACb5D,GAAG,CAAC6D,aAAa,CAACD,KAAK,CAAC;IACxB,IAAI,CAACjB,YAAY,CAAC3C,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EACA8D,OAAOA,CAACF,KAAK,EAAE;IACb5D,GAAG,CAAC+D,aAAa,CAACH,KAAK,CAAC;IACxB,IAAI,CAACjB,YAAY,CAAC3C,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EACAgE,OAAOA,CAACJ,KAAK,EAAE;IACb5D,GAAG,CAACiE,aAAa,CAACL,KAAK,CAAC;IACxB,IAAI,CAACjB,YAAY,CAAC3C,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EACAkE,SAASA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;IACjBrE,GAAG,CAACsE,eAAe,CAACH,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;IAC5B,IAAI,CAAC1B,YAAY,CAAC3C,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EACAuE,KAAKA,CAACJ,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;IACbrE,GAAG,CAACwE,SAAS,CAACL,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;IACtB,IAAI,CAAC1B,YAAY,CAAC3C,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EACAyE,MAAMA,CAACC,MAAM,EAAE;IACbzE,IAAI,CAACwE,MAAM,CAACC,MAAM,CAAC;IACnBzE,IAAI,CAAC0E,YAAY,CAAC,CAAC;IACnB,IAAI,CAAChC,YAAY,CAAC1C,IAAI,CAAC2C,MAAM,CAAC;IAC9B,OAAO,IAAI;EACb;EACAgC,kBAAkBA,CAACrE,QAAQ,EAAE;IAC3B,MAAMsE,KAAK,GAAG,IAAI;IAClB,MAAMC,KAAK,GAAGvE,QAAQ,CAACuE,KAAK,KAAK,IAAI,GAAGvE,QAAQ,CAACuE,KAAK,GAAG,KAAK,CAAC;IAC/D,MAAMC,UAAU,GAAGxE,QAAQ,CAACwE,UAAU;IACtC,IAAIA,UAAU,CAACC,QAAQ,KAAK,KAAK,CAAC,EAAE;MAClCC,OAAO,CAACC,KAAK,CAAC,kFAAkF,CAAC;MACjG,OAAO,IAAI;IACb;IACA,MAAMF,QAAQ,GAAGD,UAAU,CAACC,QAAQ;IACpC,MAAM7B,MAAM,GAAG4B,UAAU,CAAC5B,MAAM;IAChC,MAAMgC,KAAK,GAAGJ,UAAU,CAACI,KAAK;IAC9B,MAAMC,EAAE,GAAGL,UAAU,CAACK,EAAE;IACxB,MAAMC,GAAG,GAAGN,UAAU,CAACM,GAAG;IAC1B,IAAIA,GAAG,KAAK,KAAK,CAAC,EAChB,IAAI,CAACtD,aAAa,CAAC,CAAC,CAAC,GAAG,EAAE;IAC5B,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiC,QAAQ,CAACM,KAAK,EAAEvC,CAAC,EAAE,EAAE;MACvC8B,KAAK,CAAClE,QAAQ,CAAC4E,IAAI,CAAC,IAAIlG,OAAO,CAAC,CAAC,CAACmG,mBAAmB,CAACR,QAAQ,EAAEjC,CAAC,CAAC,CAAC;MACnE,IAAIoC,KAAK,KAAK,KAAK,CAAC,EAAE;QACpBN,KAAK,CAAChE,MAAM,CAAC0E,IAAI,CAAC,IAAI5F,KAAK,CAAC,CAAC,CAAC6F,mBAAmB,CAACL,KAAK,EAAEpC,CAAC,CAAC,CAAC;MAC9D;IACF;IACA,SAAS0C,OAAOA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,aAAa,EAAE;MACvC,MAAMC,YAAY,GAAGX,KAAK,KAAK,KAAK,CAAC,GAAG,EAAE,GAAG,CAACN,KAAK,CAAChE,MAAM,CAAC6E,CAAC,CAAC,CAACtE,KAAK,CAAC,CAAC,EAAEyD,KAAK,CAAChE,MAAM,CAAC8E,CAAC,CAAC,CAACvE,KAAK,CAAC,CAAC,EAAEyD,KAAK,CAAChE,MAAM,CAAC+E,CAAC,CAAC,CAACxE,KAAK,CAAC,CAAC,CAAC;MACxH,MAAMoC,aAAa,GAAGL,MAAM,KAAK,KAAK,CAAC,GAAG,EAAE,GAAG,CAC7C,IAAI9D,OAAO,CAAC,CAAC,CAACmG,mBAAmB,CAACrC,MAAM,EAAEuC,CAAC,CAAC,EAC5C,IAAIrG,OAAO,CAAC,CAAC,CAACmG,mBAAmB,CAACrC,MAAM,EAAEwC,CAAC,CAAC,EAC5C,IAAItG,OAAO,CAAC,CAAC,CAACmG,mBAAmB,CAACrC,MAAM,EAAEyC,CAAC,CAAC,CAC7C;MACD,MAAM1C,IAAI,GAAG,IAAI6C,KAAK,CAACL,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEpC,aAAa,EAAEsC,YAAY,EAAED,aAAa,CAAC;MAC3EhB,KAAK,CAAC/C,KAAK,CAACyD,IAAI,CAACrC,IAAI,CAAC;MACtB,IAAIkC,EAAE,KAAK,KAAK,CAAC,EAAE;QACjBP,KAAK,CAAC9C,aAAa,CAAC,CAAC,CAAC,CAACwD,IAAI,CAAC,CAC1B,IAAI3F,OAAO,CAAC,CAAC,CAAC4F,mBAAmB,CAACJ,EAAE,EAAEM,CAAC,CAAC,EACxC,IAAI9F,OAAO,CAAC,CAAC,CAAC4F,mBAAmB,CAACJ,EAAE,EAAEO,CAAC,CAAC,EACxC,IAAI/F,OAAO,CAAC,CAAC,CAAC4F,mBAAmB,CAACJ,EAAE,EAAEQ,CAAC,CAAC,CACzC,CAAC;MACJ;MACA,IAAIP,GAAG,KAAK,KAAK,CAAC,EAAE;QAClBR,KAAK,CAAC9C,aAAa,CAAC,CAAC,CAAC,CAACwD,IAAI,CAAC,CAC1B,IAAI3F,OAAO,CAAC,CAAC,CAAC4F,mBAAmB,CAACH,GAAG,EAAEK,CAAC,CAAC,EACzC,IAAI9F,OAAO,CAAC,CAAC,CAAC4F,mBAAmB,CAACH,GAAG,EAAEM,CAAC,CAAC,EACzC,IAAI/F,OAAO,CAAC,CAAC,CAAC4F,mBAAmB,CAACH,GAAG,EAAEO,CAAC,CAAC,CAC1C,CAAC;MACJ;IACF;IACA,MAAMI,MAAM,GAAGzF,QAAQ,CAACyF,MAAM;IAC9B,IAAIA,MAAM,CAACpF,MAAM,GAAG,CAAC,EAAE;MACrB,KAAK,IAAImC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiD,MAAM,CAACpF,MAAM,EAAEmC,CAAC,EAAE,EAAE;QACtC,MAAMkD,KAAK,GAAGD,MAAM,CAACjD,CAAC,CAAC;QACvB,MAAMmD,KAAK,GAAGD,KAAK,CAACC,KAAK;QACzB,MAAMZ,KAAK,GAAGW,KAAK,CAACX,KAAK;QACzB,KAAK,IAAIhC,CAAC,GAAG4C,KAAK,EAAE3C,EAAE,GAAG2C,KAAK,GAAGZ,KAAK,EAAEhC,CAAC,GAAGC,EAAE,EAAED,CAAC,IAAI,CAAC,EAAE;UACtD,IAAIwB,KAAK,KAAK,KAAK,CAAC,EAAE;YACpBW,OAAO,CAACX,KAAK,CAACqB,IAAI,CAAC7C,CAAC,CAAC,EAAEwB,KAAK,CAACqB,IAAI,CAAC7C,CAAC,GAAG,CAAC,CAAC,EAAEwB,KAAK,CAACqB,IAAI,CAAC7C,CAAC,GAAG,CAAC,CAAC,EAAE2C,KAAK,CAACJ,aAAa,CAAC;UACnF,CAAC,MAAM;YACLJ,OAAO,CAACnC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE2C,KAAK,CAACJ,aAAa,CAAC;UAC/C;QACF;MACF;IACF,CAAC,MAAM;MACL,IAAIf,KAAK,KAAK,KAAK,CAAC,EAAE;QACpB,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,KAAK,CAACQ,KAAK,EAAEvC,CAAC,IAAI,CAAC,EAAE;UACvC0C,OAAO,CAACX,KAAK,CAACqB,IAAI,CAACpD,CAAC,CAAC,EAAE+B,KAAK,CAACqB,IAAI,CAACpD,CAAC,GAAG,CAAC,CAAC,EAAE+B,KAAK,CAACqB,IAAI,CAACpD,CAAC,GAAG,CAAC,CAAC,CAAC;QAC9D;MACF,CAAC,MAAM;QACL,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiC,QAAQ,CAACM,KAAK,EAAEvC,CAAC,IAAI,CAAC,EAAE;UAC1C0C,OAAO,CAAC1C,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;QAC1B;MACF;IACF;IACA,IAAI,CAACqD,kBAAkB,CAAC,CAAC;IACzB,IAAI7F,QAAQ,CAACc,WAAW,KAAK,IAAI,EAAE;MACjC,IAAI,CAACA,WAAW,GAAGd,QAAQ,CAACc,WAAW,CAACD,KAAK,CAAC,CAAC;IACjD;IACA,IAAIb,QAAQ,CAACY,cAAc,KAAK,IAAI,EAAE;MACpC,IAAI,CAACA,cAAc,GAAGZ,QAAQ,CAACY,cAAc,CAACC,KAAK,CAAC,CAAC;IACvD;IACA,OAAO,IAAI;EACb;EACAiF,MAAMA,CAAA,EAAG;IACP,IAAI,CAAC5C,kBAAkB,CAAC,CAAC;IACzB,IAAI,CAACpC,WAAW,CAACiF,SAAS,CAACpG,OAAO,CAAC,CAACqG,MAAM,CAAC,CAAC;IAC5C,IAAI,CAACrC,SAAS,CAAChE,OAAO,CAACiE,CAAC,EAAEjE,OAAO,CAACkE,CAAC,EAAElE,OAAO,CAACmE,CAAC,CAAC;IAC/C,OAAO,IAAI;EACb;EACAhB,SAASA,CAAA,EAAG;IACV,IAAI,CAACK,qBAAqB,CAAC,CAAC;IAC5B,MAAM2C,MAAM,GAAG,IAAI,CAAClF,cAAc,CAACkF,MAAM;IACzC,MAAMG,MAAM,GAAG,IAAI,CAACrF,cAAc,CAACqF,MAAM;IACzC,MAAMC,CAAC,GAAGD,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,GAAGA,MAAM;IACvC,MAAM5D,MAAM,GAAG,IAAIzD,OAAO,CAAC,CAAC;IAC5ByD,MAAM,CAAC8D,GAAG,CAACD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAACA,CAAC,GAAGJ,MAAM,CAAClC,CAAC,EAAE,CAAC,EAAEsC,CAAC,EAAE,CAAC,EAAE,CAACA,CAAC,GAAGJ,MAAM,CAACjC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEqC,CAAC,EAAE,CAACA,CAAC,GAAGJ,MAAM,CAAChC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC9F,IAAI,CAAC1B,YAAY,CAACC,MAAM,CAAC;IACzB,OAAO,IAAI;EACb;EACAwD,kBAAkBA,CAAA,EAAG;IACnB,MAAMO,EAAE,GAAG,IAAItH,OAAO,CAAC,CAAC;MAAEuH,EAAE,GAAG,IAAIvH,OAAO,CAAC,CAAC;IAC5C,KAAK,IAAIwH,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChF,KAAK,CAAClB,MAAM,EAAEiG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM3D,IAAI,GAAG,IAAI,CAACpB,KAAK,CAAC+E,CAAC,CAAC;MAC1B,MAAME,EAAE,GAAG,IAAI,CAACpG,QAAQ,CAACuC,IAAI,CAACwC,CAAC,CAAC;MAChC,MAAMsB,EAAE,GAAG,IAAI,CAACrG,QAAQ,CAACuC,IAAI,CAACyC,CAAC,CAAC;MAChC,MAAMsB,EAAE,GAAG,IAAI,CAACtG,QAAQ,CAACuC,IAAI,CAAC0C,CAAC,CAAC;MAChCe,EAAE,CAACO,UAAU,CAACD,EAAE,EAAED,EAAE,CAAC;MACrBJ,EAAE,CAACM,UAAU,CAACH,EAAE,EAAEC,EAAE,CAAC;MACrBL,EAAE,CAACQ,KAAK,CAACP,EAAE,CAAC;MACZD,EAAE,CAACtD,SAAS,CAAC,CAAC;MACdH,IAAI,CAACC,MAAM,CAACiE,IAAI,CAACT,EAAE,CAAC;IACtB;EACF;EACAU,oBAAoBA,CAACC,YAAY,GAAG,IAAI,EAAE;IACxC,MAAM3G,QAAQ,GAAG,IAAI4G,KAAK,CAAC,IAAI,CAAC5G,QAAQ,CAACC,MAAM,CAAC;IAChD,KAAK,IAAI4G,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAC9G,QAAQ,CAACC,MAAM,EAAE4G,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACtD7G,QAAQ,CAAC6G,CAAC,CAAC,GAAG,IAAInI,OAAO,CAAC,CAAC;IAC7B;IACA,IAAIiI,YAAY,EAAE;MAChB,MAAMX,EAAE,GAAG,IAAItH,OAAO,CAAC,CAAC;QAAEuH,EAAE,GAAG,IAAIvH,OAAO,CAAC,CAAC;MAC5C,KAAK,IAAIwH,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChF,KAAK,CAAClB,MAAM,EAAEiG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACnD,MAAM3D,IAAI,GAAG,IAAI,CAACpB,KAAK,CAAC+E,CAAC,CAAC;QAC1B,MAAME,EAAE,GAAG,IAAI,CAACpG,QAAQ,CAACuC,IAAI,CAACwC,CAAC,CAAC;QAChC,MAAMsB,EAAE,GAAG,IAAI,CAACrG,QAAQ,CAACuC,IAAI,CAACyC,CAAC,CAAC;QAChC,MAAMsB,EAAE,GAAG,IAAI,CAACtG,QAAQ,CAACuC,IAAI,CAAC0C,CAAC,CAAC;QAChCe,EAAE,CAACO,UAAU,CAACD,EAAE,EAAED,EAAE,CAAC;QACrBJ,EAAE,CAACM,UAAU,CAACH,EAAE,EAAEC,EAAE,CAAC;QACrBL,EAAE,CAACQ,KAAK,CAACP,EAAE,CAAC;QACZjG,QAAQ,CAACuC,IAAI,CAACwC,CAAC,CAAC,CAACgC,GAAG,CAACf,EAAE,CAAC;QACxBhG,QAAQ,CAACuC,IAAI,CAACyC,CAAC,CAAC,CAAC+B,GAAG,CAACf,EAAE,CAAC;QACxBhG,QAAQ,CAACuC,IAAI,CAAC0C,CAAC,CAAC,CAAC8B,GAAG,CAACf,EAAE,CAAC;MAC1B;IACF,CAAC,MAAM;MACL,IAAI,CAACP,kBAAkB,CAAC,CAAC;MACzB,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChF,KAAK,CAAClB,MAAM,EAAEiG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACnD,MAAM3D,IAAI,GAAG,IAAI,CAACpB,KAAK,CAAC+E,CAAC,CAAC;QAC1BlG,QAAQ,CAACuC,IAAI,CAACwC,CAAC,CAAC,CAACgC,GAAG,CAACxE,IAAI,CAACC,MAAM,CAAC;QACjCxC,QAAQ,CAACuC,IAAI,CAACyC,CAAC,CAAC,CAAC+B,GAAG,CAACxE,IAAI,CAACC,MAAM,CAAC;QACjCxC,QAAQ,CAACuC,IAAI,CAAC0C,CAAC,CAAC,CAAC8B,GAAG,CAACxE,IAAI,CAACC,MAAM,CAAC;MACnC;IACF;IACA,KAAK,IAAIqE,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAC9G,QAAQ,CAACC,MAAM,EAAE4G,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACtD7G,QAAQ,CAAC6G,CAAC,CAAC,CAACnE,SAAS,CAAC,CAAC;IACzB;IACA,KAAK,IAAIwD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChF,KAAK,CAAClB,MAAM,EAAEiG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM3D,IAAI,GAAG,IAAI,CAACpB,KAAK,CAAC+E,CAAC,CAAC;MAC1B,MAAMrD,aAAa,GAAGN,IAAI,CAACM,aAAa;MACxC,IAAIA,aAAa,CAAC5C,MAAM,KAAK,CAAC,EAAE;QAC9B4C,aAAa,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACzG,QAAQ,CAACuC,IAAI,CAACwC,CAAC,CAAC,CAAC;QACvClC,aAAa,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACzG,QAAQ,CAACuC,IAAI,CAACyC,CAAC,CAAC,CAAC;QACvCnC,aAAa,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACzG,QAAQ,CAACuC,IAAI,CAAC0C,CAAC,CAAC,CAAC;MACzC,CAAC,MAAM;QACLpC,aAAa,CAAC,CAAC,CAAC,GAAG7C,QAAQ,CAACuC,IAAI,CAACwC,CAAC,CAAC,CAACtE,KAAK,CAAC,CAAC;QAC3CoC,aAAa,CAAC,CAAC,CAAC,GAAG7C,QAAQ,CAACuC,IAAI,CAACyC,CAAC,CAAC,CAACvE,KAAK,CAAC,CAAC;QAC3CoC,aAAa,CAAC,CAAC,CAAC,GAAG7C,QAAQ,CAACuC,IAAI,CAAC0C,CAAC,CAAC,CAACxE,KAAK,CAAC,CAAC;MAC7C;IACF;IACA,IAAI,IAAI,CAACU,KAAK,CAAClB,MAAM,GAAG,CAAC,EAAE;MACzB,IAAI,CAAC2B,iBAAiB,GAAG,IAAI;IAC/B;EACF;EACAoF,wBAAwBA,CAAA,EAAG;IACzB,IAAI,CAACvB,kBAAkB,CAAC,CAAC;IACzB,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChF,KAAK,CAAClB,MAAM,EAAEiG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM3D,IAAI,GAAG,IAAI,CAACpB,KAAK,CAAC+E,CAAC,CAAC;MAC1B,MAAMrD,aAAa,GAAGN,IAAI,CAACM,aAAa;MACxC,IAAIA,aAAa,CAAC5C,MAAM,KAAK,CAAC,EAAE;QAC9B4C,aAAa,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAAClE,IAAI,CAACC,MAAM,CAAC;QAClCK,aAAa,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAAClE,IAAI,CAACC,MAAM,CAAC;QAClCK,aAAa,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAAClE,IAAI,CAACC,MAAM,CAAC;MACpC,CAAC,MAAM;QACLK,aAAa,CAAC,CAAC,CAAC,GAAGN,IAAI,CAACC,MAAM,CAAC/B,KAAK,CAAC,CAAC;QACtCoC,aAAa,CAAC,CAAC,CAAC,GAAGN,IAAI,CAACC,MAAM,CAAC/B,KAAK,CAAC,CAAC;QACtCoC,aAAa,CAAC,CAAC,CAAC,GAAGN,IAAI,CAACC,MAAM,CAAC/B,KAAK,CAAC,CAAC;MACxC;IACF;IACA,IAAI,IAAI,CAACU,KAAK,CAAClB,MAAM,GAAG,CAAC,EAAE;MACzB,IAAI,CAAC2B,iBAAiB,GAAG,IAAI;IAC/B;EACF;EACAqF,mBAAmBA,CAAA,EAAG;IACpB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChF,KAAK,CAAClB,MAAM,EAAEiG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM3D,IAAI,GAAG,IAAI,CAACpB,KAAK,CAAC+E,CAAC,CAAC;MAC1B,IAAI,CAAC3D,IAAI,CAAC2E,oBAAoB,EAAE;QAC9B3E,IAAI,CAAC2E,oBAAoB,GAAG3E,IAAI,CAACC,MAAM,CAAC/B,KAAK,CAAC,CAAC;MACjD,CAAC,MAAM;QACL8B,IAAI,CAAC2E,oBAAoB,CAACT,IAAI,CAAClE,IAAI,CAACC,MAAM,CAAC;MAC7C;MACA,IAAI,CAACD,IAAI,CAAC4E,uBAAuB,EAC/B5E,IAAI,CAAC4E,uBAAuB,GAAG,EAAE;MACnC,KAAK,IAAI/E,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGE,IAAI,CAACM,aAAa,CAAC5C,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QAC3D,IAAI,CAACG,IAAI,CAAC4E,uBAAuB,CAAC/E,CAAC,CAAC,EAAE;UACpCG,IAAI,CAAC4E,uBAAuB,CAAC/E,CAAC,CAAC,GAAGG,IAAI,CAACM,aAAa,CAACT,CAAC,CAAC,CAAC3B,KAAK,CAAC,CAAC;QACjE,CAAC,MAAM;UACL8B,IAAI,CAAC4E,uBAAuB,CAAC/E,CAAC,CAAC,CAACqE,IAAI,CAAClE,IAAI,CAACM,aAAa,CAACT,CAAC,CAAC,CAAC;QAC7D;MACF;IACF;IACA,MAAMgF,MAAM,GAAG,IAAI5H,QAAQ,CAAC,CAAC;IAC7B4H,MAAM,CAACjG,KAAK,GAAG,IAAI,CAACA,KAAK;IACzB,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChB,YAAY,CAACpB,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC1D,IAAI,CAAC,IAAI,CAACd,YAAY,CAACc,CAAC,CAAC,EAAE;QACzB,IAAI,CAACd,YAAY,CAACc,CAAC,CAAC,GAAG,CAAC,CAAC;QACzB,IAAI,CAACd,YAAY,CAACc,CAAC,CAAC,CAACiF,WAAW,GAAG,EAAE;QACrC,IAAI,CAAC/F,YAAY,CAACc,CAAC,CAAC,CAACS,aAAa,GAAG,EAAE;QACvC,MAAMyE,cAAc,GAAG,IAAI,CAAChG,YAAY,CAACc,CAAC,CAAC,CAACiF,WAAW;QACvD,MAAME,gBAAgB,GAAG,IAAI,CAACjG,YAAY,CAACc,CAAC,CAAC,CAACS,aAAa;QAC3D,KAAK,IAAIqD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChF,KAAK,CAAClB,MAAM,EAAEiG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UACnD,MAAMsB,UAAU,GAAG,IAAI9I,OAAO,CAAC,CAAC;UAChC,MAAMmE,aAAa,GAAG;YACpBkC,CAAC,EAAE,IAAIrG,OAAO,CAAC,CAAC;YAChBsG,CAAC,EAAE,IAAItG,OAAO,CAAC,CAAC;YAChBuG,CAAC,EAAE,IAAIvG,OAAO,CAAC;UACjB,CAAC;UACD4I,cAAc,CAAC1C,IAAI,CAAC4C,UAAU,CAAC;UAC/BD,gBAAgB,CAAC3C,IAAI,CAAC/B,aAAa,CAAC;QACtC;MACF;MACA,MAAMvB,YAAY,GAAG,IAAI,CAACA,YAAY,CAACc,CAAC,CAAC;MACzCgF,MAAM,CAACpH,QAAQ,GAAG,IAAI,CAACqB,YAAY,CAACe,CAAC,CAAC,CAACpC,QAAQ;MAC/CoH,MAAM,CAAC3B,kBAAkB,CAAC,CAAC;MAC3B2B,MAAM,CAACV,oBAAoB,CAAC,CAAC;MAC7B,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChF,KAAK,CAAClB,MAAM,EAAEiG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACnD,MAAM3D,IAAI,GAAG,IAAI,CAACpB,KAAK,CAAC+E,CAAC,CAAC;QAC1B,MAAMsB,UAAU,GAAGlG,YAAY,CAAC+F,WAAW,CAACnB,CAAC,CAAC;QAC9C,MAAMrD,aAAa,GAAGvB,YAAY,CAACuB,aAAa,CAACqD,CAAC,CAAC;QACnDsB,UAAU,CAACf,IAAI,CAAClE,IAAI,CAACC,MAAM,CAAC;QAC5BK,aAAa,CAACkC,CAAC,CAAC0B,IAAI,CAAClE,IAAI,CAACM,aAAa,CAAC,CAAC,CAAC,CAAC;QAC3CA,aAAa,CAACmC,CAAC,CAACyB,IAAI,CAAClE,IAAI,CAACM,aAAa,CAAC,CAAC,CAAC,CAAC;QAC3CA,aAAa,CAACoC,CAAC,CAACwB,IAAI,CAAClE,IAAI,CAACM,aAAa,CAAC,CAAC,CAAC,CAAC;MAC7C;IACF;IACA,KAAK,IAAIqD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChF,KAAK,CAAClB,MAAM,EAAEiG,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM3D,IAAI,GAAG,IAAI,CAACpB,KAAK,CAAC+E,CAAC,CAAC;MAC1B3D,IAAI,CAACC,MAAM,GAAGD,IAAI,CAAC2E,oBAAoB;MACvC3E,IAAI,CAACM,aAAa,GAAGN,IAAI,CAAC4E,uBAAuB;IACnD;EACF;EACArE,kBAAkBA,CAAA,EAAG;IACnB,IAAI,IAAI,CAACpC,WAAW,KAAK,IAAI,EAAE;MAC7B,IAAI,CAACA,WAAW,GAAG,IAAIxB,IAAI,CAAC,CAAC;IAC/B;IACA,IAAI,CAACwB,WAAW,CAAC+G,aAAa,CAAC,IAAI,CAACzH,QAAQ,CAAC;EAC/C;EACA+C,qBAAqBA,CAAA,EAAG;IACtB,IAAI,IAAI,CAACvC,cAAc,KAAK,IAAI,EAAE;MAChC,IAAI,CAACA,cAAc,GAAG,IAAIrB,MAAM,CAAC,CAAC;IACpC;IACA,IAAI,CAACqB,cAAc,CAACiH,aAAa,CAAC,IAAI,CAACzH,QAAQ,CAAC;EAClD;EACA0H,KAAKA,CAAC9H,QAAQ,EAAEqC,MAAM,EAAE0F,mBAAmB,GAAG,CAAC,EAAE;IAC/C,IAAI,EAAE/H,QAAQ,IAAIA,QAAQ,CAACkB,UAAU,CAAC,EAAE;MACtCwD,OAAO,CAACC,KAAK,CAAC,qEAAqE,EAAE3E,QAAQ,CAAC;MAC9F;IACF;IACA,IAAIsC,YAAY;IAChB,MAAM0F,YAAY,GAAG,IAAI,CAAC5H,QAAQ,CAACC,MAAM;MAAE4H,SAAS,GAAG,IAAI,CAAC7H,QAAQ;MAAE8H,SAAS,GAAGlI,QAAQ,CAACI,QAAQ;MAAE+H,MAAM,GAAG,IAAI,CAAC5G,KAAK;MAAE6G,MAAM,GAAGpI,QAAQ,CAACuB,KAAK;MAAE8G,OAAO,GAAG,IAAI,CAAC/H,MAAM;MAAEgI,OAAO,GAAGtI,QAAQ,CAACM,MAAM;IACnM,IAAI+B,MAAM,KAAK,KAAK,CAAC,EAAE;MACrBC,YAAY,GAAG,IAAInD,OAAO,CAAC,CAAC,CAACoD,eAAe,CAACF,MAAM,CAAC;IACtD;IACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGyF,SAAS,CAAC7H,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAClD,MAAME,MAAM,GAAGwF,SAAS,CAAC1F,CAAC,CAAC;MAC3B,MAAM+F,UAAU,GAAG7F,MAAM,CAAC7B,KAAK,CAAC,CAAC;MACjC,IAAIwB,MAAM,KAAK,KAAK,CAAC,EACnBkG,UAAU,CAACnG,YAAY,CAACC,MAAM,CAAC;MACjC4F,SAAS,CAACjD,IAAI,CAACuD,UAAU,CAAC;IAC5B;IACA,KAAK,IAAI/F,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG6F,OAAO,CAACjI,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAChD6F,OAAO,CAACrD,IAAI,CAACsD,OAAO,CAAC9F,CAAC,CAAC,CAAC3B,KAAK,CAAC,CAAC,CAAC;IAClC;IACA,KAAK,IAAI2B,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG2F,MAAM,CAAC/H,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC/C,MAAMG,IAAI,GAAGyF,MAAM,CAAC5F,CAAC,CAAC;MACtB,IAAII,MAAM,EAAEgC,KAAK;MACjB,MAAM4D,iBAAiB,GAAG7F,IAAI,CAACM,aAAa;QAAEwF,gBAAgB,GAAG9F,IAAI,CAAC4C,YAAY;MAClF,MAAMmD,QAAQ,GAAG,IAAIlD,KAAK,CAAC7C,IAAI,CAACwC,CAAC,GAAG6C,YAAY,EAAErF,IAAI,CAACyC,CAAC,GAAG4C,YAAY,EAAErF,IAAI,CAAC0C,CAAC,GAAG2C,YAAY,CAAC;MAC/FU,QAAQ,CAAC9F,MAAM,CAACiE,IAAI,CAAClE,IAAI,CAACC,MAAM,CAAC;MACjC,IAAIN,YAAY,KAAK,KAAK,CAAC,EAAE;QAC3BoG,QAAQ,CAAC9F,MAAM,CAACC,YAAY,CAACP,YAAY,CAAC,CAACQ,SAAS,CAAC,CAAC;MACxD;MACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGwF,iBAAiB,CAACnI,MAAM,EAAE0C,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QAC1DH,MAAM,GAAG4F,iBAAiB,CAACzF,CAAC,CAAC,CAAClC,KAAK,CAAC,CAAC;QACrC,IAAIyB,YAAY,KAAK,KAAK,CAAC,EAAE;UAC3BM,MAAM,CAACC,YAAY,CAACP,YAAY,CAAC,CAACQ,SAAS,CAAC,CAAC;QAC/C;QACA4F,QAAQ,CAACzF,aAAa,CAAC+B,IAAI,CAACpC,MAAM,CAAC;MACrC;MACA8F,QAAQ,CAAC9D,KAAK,CAACiC,IAAI,CAAClE,IAAI,CAACiC,KAAK,CAAC;MAC/B,KAAK,IAAI7B,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGyF,gBAAgB,CAACpI,MAAM,EAAE0C,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACzD6B,KAAK,GAAG6D,gBAAgB,CAAC1F,CAAC,CAAC;QAC3B2F,QAAQ,CAACnD,YAAY,CAACP,IAAI,CAACJ,KAAK,CAAC/D,KAAK,CAAC,CAAC,CAAC;MAC3C;MACA6H,QAAQ,CAACpD,aAAa,GAAG3C,IAAI,CAAC2C,aAAa,GAAGyC,mBAAmB;MACjEI,MAAM,CAACnD,IAAI,CAAC0D,QAAQ,CAAC;IACvB;IACA,KAAK,IAAIlG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGzC,QAAQ,CAACwB,aAAa,CAACnB,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC/D,MAAMmG,cAAc,GAAG3I,QAAQ,CAACwB,aAAa,CAACgB,CAAC,CAAC;MAChD,IAAI,IAAI,CAAChB,aAAa,CAACgB,CAAC,CAAC,KAAK,KAAK,CAAC,EAClC,IAAI,CAAChB,aAAa,CAACgB,CAAC,CAAC,GAAG,EAAE;MAC5B,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG2F,cAAc,CAACtI,MAAM,EAAE0C,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACvD,MAAM6F,IAAI,GAAGD,cAAc,CAAC5F,CAAC,CAAC;UAAE8F,OAAO,GAAG,EAAE;QAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGH,IAAI,CAACvI,MAAM,EAAEyI,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UAC7CD,OAAO,CAAC7D,IAAI,CAAC4D,IAAI,CAACE,CAAC,CAAC,CAACjI,KAAK,CAAC,CAAC,CAAC;QAC/B;QACA,IAAI,CAACW,aAAa,CAACgB,CAAC,CAAC,CAACwC,IAAI,CAAC6D,OAAO,CAAC;MACrC;IACF;EACF;EACAG,SAASA,CAACC,IAAI,EAAE;IACd,IAAI,EAAEA,IAAI,IAAIA,IAAI,CAAClI,MAAM,CAAC,EAAE;MAC1B2D,OAAO,CAACC,KAAK,CAAC,iEAAiE,EAAEsE,IAAI,CAAC;MACtF;IACF;IACA,IAAIA,IAAI,CAACC,gBAAgB,EACvBD,IAAI,CAAC7E,YAAY,CAAC,CAAC;IACrB,IAAI,CAAC0D,KAAK,CAACmB,IAAI,CAACjJ,QAAQ,EAAEiJ,IAAI,CAAC5G,MAAM,CAAC;EACxC;EACA;AACF;AACA;AACA;AACA;EACE8G,aAAaA,CAACC,eAAe,GAAG,CAAC,EAAE;IACjC,MAAMC,WAAW,GAAG,CAAC,CAAC;IACtB,MAAMC,MAAM,GAAG,EAAE;MAAEC,OAAO,GAAG,EAAE;IAC/B,MAAMC,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,EAAE,EAAEN,eAAe,CAAC;IAC/C,KAAK,IAAI5G,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACrC,QAAQ,CAACC,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACtD,MAAMyE,CAAC,GAAG,IAAI,CAAC7G,QAAQ,CAACoC,CAAC,CAAC;MAC1B,MAAMmH,GAAG,GAAI,GAAEF,IAAI,CAACG,KAAK,CAAC3C,CAAC,CAACrD,CAAC,GAAG4F,SAAS,CAAE,IAAGC,IAAI,CAACG,KAAK,CAAC3C,CAAC,CAACpD,CAAC,GAAG2F,SAAS,CAAE,IAAGC,IAAI,CAACG,KAAK,CAAC3C,CAAC,CAACnD,CAAC,GAAG0F,SAAS,CAAE,EAAC;MAC1G,IAAIH,WAAW,CAACM,GAAG,CAAC,KAAK,KAAK,CAAC,EAAE;QAC/BN,WAAW,CAACM,GAAG,CAAC,GAAGnH,CAAC;QACpB8G,MAAM,CAACtE,IAAI,CAAC,IAAI,CAAC5E,QAAQ,CAACoC,CAAC,CAAC,CAAC;QAC7B+G,OAAO,CAAC/G,CAAC,CAAC,GAAG8G,MAAM,CAACjJ,MAAM,GAAG,CAAC;MAChC,CAAC,MAAM;QACLkJ,OAAO,CAAC/G,CAAC,CAAC,GAAG+G,OAAO,CAACF,WAAW,CAACM,GAAG,CAAC,CAAC;MACxC;IACF;IACA,MAAME,mBAAmB,GAAG,EAAE;IAC9B,KAAK,IAAIrH,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAClB,KAAK,CAAClB,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMG,IAAI,GAAG,IAAI,CAACpB,KAAK,CAACiB,CAAC,CAAC;MAC1BG,IAAI,CAACwC,CAAC,GAAGoE,OAAO,CAAC5G,IAAI,CAACwC,CAAC,CAAC;MACxBxC,IAAI,CAACyC,CAAC,GAAGmE,OAAO,CAAC5G,IAAI,CAACyC,CAAC,CAAC;MACxBzC,IAAI,CAAC0C,CAAC,GAAGkE,OAAO,CAAC5G,IAAI,CAAC0C,CAAC,CAAC;MACxB,MAAMyE,OAAO,GAAG,CAACnH,IAAI,CAACwC,CAAC,EAAExC,IAAI,CAACyC,CAAC,EAAEzC,IAAI,CAAC0C,CAAC,CAAC;MACxC,KAAK,IAAI0E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC1B,IAAID,OAAO,CAACC,CAAC,CAAC,KAAKD,OAAO,CAAC,CAACC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;UACvCF,mBAAmB,CAAC7E,IAAI,CAACxC,CAAC,CAAC;UAC3B;QACF;MACF;IACF;IACA,KAAK,IAAIA,CAAC,GAAGqH,mBAAmB,CAACxJ,MAAM,GAAG,CAAC,EAAEmC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACxD,MAAMwH,GAAG,GAAGH,mBAAmB,CAACrH,CAAC,CAAC;MAClC,IAAI,CAACjB,KAAK,CAAC0I,MAAM,CAACD,GAAG,EAAE,CAAC,CAAC;MACzB,KAAK,IAAIjH,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAACxB,aAAa,CAACnB,MAAM,EAAE0C,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QAC3D,IAAI,CAACvB,aAAa,CAACuB,CAAC,CAAC,CAACkH,MAAM,CAACD,GAAG,EAAE,CAAC,CAAC;MACtC;IACF;IACA,MAAME,IAAI,GAAG,IAAI,CAAC9J,QAAQ,CAACC,MAAM,GAAGiJ,MAAM,CAACjJ,MAAM;IACjD,IAAI,CAACD,QAAQ,GAAGkJ,MAAM;IACtB,OAAOY,IAAI;EACb;EACArC,aAAaA,CAACsC,MAAM,EAAE;IACpB,IAAI,CAAC/J,QAAQ,GAAG,EAAE;IAClB,KAAK,IAAIoC,CAAC,GAAG,CAAC,EAAE4H,CAAC,GAAGD,MAAM,CAAC9J,MAAM,EAAEmC,CAAC,GAAG4H,CAAC,EAAE5H,CAAC,EAAE,EAAE;MAC7C,MAAM6H,KAAK,GAAGF,MAAM,CAAC3H,CAAC,CAAC;MACvB,IAAI,CAACpC,QAAQ,CAAC4E,IAAI,CAAC,IAAIlG,OAAO,CAACuL,KAAK,CAACzG,CAAC,EAAEyG,KAAK,CAACxG,CAAC,EAAEwG,KAAK,CAACvG,CAAC,IAAI,CAAC,CAAC,CAAC;IACjE;IACA,OAAO,IAAI;EACb;EACAwG,wBAAwBA,CAAA,EAAG;IACzB,MAAM/I,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,MAAMlB,MAAM,GAAGkB,KAAK,CAAClB,MAAM;IAC3B,KAAK,IAAImC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnC,MAAM,EAAEmC,CAAC,EAAE,EAAE;MAC/BjB,KAAK,CAACiB,CAAC,CAAC,CAAC+H,GAAG,GAAG/H,CAAC;IAClB;IACA,SAASgI,iBAAiBA,CAACrF,CAAC,EAAEC,CAAC,EAAE;MAC/B,OAAOD,CAAC,CAACG,aAAa,GAAGF,CAAC,CAACE,aAAa;IAC1C;IACA/D,KAAK,CAACkJ,IAAI,CAACD,iBAAiB,CAAC;IAC7B,MAAME,IAAI,GAAG,IAAI,CAAClJ,aAAa,CAAC,CAAC,CAAC;IAClC,MAAMoH,IAAI,GAAG,IAAI,CAACpH,aAAa,CAAC,CAAC,CAAC;IAClC,IAAImJ,OAAO,EAAEC,OAAO;IACpB,IAAIF,IAAI,IAAIA,IAAI,CAACrK,MAAM,KAAKA,MAAM,EAChCsK,OAAO,GAAG,EAAE;IACd,IAAI/B,IAAI,IAAIA,IAAI,CAACvI,MAAM,KAAKA,MAAM,EAChCuK,OAAO,GAAG,EAAE;IACd,KAAK,IAAIpI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnC,MAAM,EAAEmC,CAAC,EAAE,EAAE;MAC/B,MAAMqI,EAAE,GAAGtJ,KAAK,CAACiB,CAAC,CAAC,CAAC+H,GAAG;MACvB,IAAII,OAAO,EACTA,OAAO,CAAC3F,IAAI,CAAC0F,IAAI,CAACG,EAAE,CAAC,CAAC;MACxB,IAAID,OAAO,EACTA,OAAO,CAAC5F,IAAI,CAAC4D,IAAI,CAACiC,EAAE,CAAC,CAAC;IAC1B;IACA,IAAIF,OAAO,EACT,IAAI,CAACnJ,aAAa,CAAC,CAAC,CAAC,GAAGmJ,OAAO;IACjC,IAAIC,OAAO,EACT,IAAI,CAACpJ,aAAa,CAAC,CAAC,CAAC,GAAGoJ,OAAO;EACnC;EACAE,MAAMA,CAAA,EAAG;IACP,MAAMC,IAAI,GAAG;MACXC,QAAQ,EAAE;QACRC,OAAO,EAAE,GAAG;QACZ3J,IAAI,EAAE,UAAU;QAChB4J,SAAS,EAAE;MACb;IACF,CAAC;IACDH,IAAI,CAAC5J,IAAI,GAAG,IAAI,CAACA,IAAI;IACrB4J,IAAI,CAACzJ,IAAI,GAAG,IAAI,CAACA,IAAI;IACrB,IAAI,IAAI,CAACD,IAAI,KAAK,EAAE,EAClB0J,IAAI,CAAC1J,IAAI,GAAG,IAAI,CAACA,IAAI;IACvB,IAAI,IAAI,CAAC8J,UAAU,KAAK,KAAK,CAAC,EAAE;MAC9B,MAAMA,UAAU,GAAG,IAAI,CAACA,UAAU;MAClC,KAAK,IAAIxB,GAAG,IAAIwB,UAAU,EAAE;QAC1B,IAAIA,UAAU,CAACxB,GAAG,CAAC,KAAK,KAAK,CAAC,EAC5BoB,IAAI,CAACpB,GAAG,CAAC,GAAGwB,UAAU,CAACxB,GAAG,CAAC;MAC/B;MACA,OAAOoB,IAAI;IACb;IACA,MAAM3K,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIoC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACpC,QAAQ,CAACC,MAAM,EAAEmC,CAAC,EAAE,EAAE;MAC7C,MAAME,MAAM,GAAG,IAAI,CAACtC,QAAQ,CAACoC,CAAC,CAAC;MAC/BpC,QAAQ,CAAC4E,IAAI,CAACtC,MAAM,CAACkB,CAAC,EAAElB,MAAM,CAACmB,CAAC,EAAEnB,MAAM,CAACoB,CAAC,CAAC;IAC7C;IACA,MAAMvC,KAAK,GAAG,EAAE;IAChB,MAAM6J,OAAO,GAAG,EAAE;IAClB,MAAMC,WAAW,GAAG,CAAC,CAAC;IACtB,MAAM/K,MAAM,GAAG,EAAE;IACjB,MAAMgL,UAAU,GAAG,CAAC,CAAC;IACrB,MAAMC,GAAG,GAAG,EAAE;IACd,MAAMC,OAAO,GAAG,CAAC,CAAC;IAClB,KAAK,IAAIhJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACjB,KAAK,CAAClB,MAAM,EAAEmC,CAAC,EAAE,EAAE;MAC1C,MAAMG,IAAI,GAAG,IAAI,CAACpB,KAAK,CAACiB,CAAC,CAAC;MAC1B,MAAMiJ,WAAW,GAAG,IAAI;MACxB,MAAMC,SAAS,GAAG,KAAK;MACvB,MAAMC,eAAe,GAAG,IAAI,CAACnK,aAAa,CAAC,CAAC,CAAC,CAACgB,CAAC,CAAC,KAAK,KAAK,CAAC;MAC3D,MAAMoJ,aAAa,GAAGjJ,IAAI,CAACC,MAAM,CAACvC,MAAM,CAAC,CAAC,GAAG,CAAC;MAC9C,MAAMwL,mBAAmB,GAAGlJ,IAAI,CAACM,aAAa,CAAC5C,MAAM,GAAG,CAAC;MACzD,MAAMyL,YAAY,GAAGnJ,IAAI,CAACiC,KAAK,CAACmH,CAAC,KAAK,CAAC,IAAIpJ,IAAI,CAACiC,KAAK,CAACoH,CAAC,KAAK,CAAC,IAAIrJ,IAAI,CAACiC,KAAK,CAACQ,CAAC,KAAK,CAAC;MACnF,MAAM6G,kBAAkB,GAAGtJ,IAAI,CAAC4C,YAAY,CAAClF,MAAM,GAAG,CAAC;MACvD,IAAI6L,QAAQ,GAAG,CAAC;MAChBA,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;MACjCA,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAET,WAAW,CAAC;MAC3CS,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAER,SAAS,CAAC;MACzCQ,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAEP,eAAe,CAAC;MAC/CO,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAEN,aAAa,CAAC;MAC7CM,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAEL,mBAAmB,CAAC;MACnDK,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAEJ,YAAY,CAAC;MAC5CI,QAAQ,GAAGC,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAED,kBAAkB,CAAC;MAClD1K,KAAK,CAACyD,IAAI,CAACkH,QAAQ,CAAC;MACpB3K,KAAK,CAACyD,IAAI,CAACrC,IAAI,CAACwC,CAAC,EAAExC,IAAI,CAACyC,CAAC,EAAEzC,IAAI,CAAC0C,CAAC,CAAC;MAClC9D,KAAK,CAACyD,IAAI,CAACrC,IAAI,CAAC2C,aAAa,CAAC;MAC9B,IAAIqG,eAAe,EAAE;QACnB,MAAMnK,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC,CAAC,CAAC,CAACgB,CAAC,CAAC;QAC9CjB,KAAK,CAACyD,IAAI,CAACoH,UAAU,CAAC5K,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE4K,UAAU,CAAC5K,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE4K,UAAU,CAAC5K,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;MACtG;MACA,IAAIoK,aAAa,EAAE;QACjBrK,KAAK,CAACyD,IAAI,CAACqH,cAAc,CAAC1J,IAAI,CAACC,MAAM,CAAC,CAAC;MACzC;MACA,IAAIiJ,mBAAmB,EAAE;QACvB,MAAM5I,aAAa,GAAGN,IAAI,CAACM,aAAa;QACxC1B,KAAK,CAACyD,IAAI,CAACqH,cAAc,CAACpJ,aAAa,CAAC,CAAC,CAAC,CAAC,EAAEoJ,cAAc,CAACpJ,aAAa,CAAC,CAAC,CAAC,CAAC,EAAEoJ,cAAc,CAACpJ,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;MAClH;MACA,IAAI6I,YAAY,EAAE;QAChBvK,KAAK,CAACyD,IAAI,CAACsH,aAAa,CAAC3J,IAAI,CAACiC,KAAK,CAAC,CAAC;MACvC;MACA,IAAIqH,kBAAkB,EAAE;QACtB,MAAM1G,YAAY,GAAG5C,IAAI,CAAC4C,YAAY;QACtChE,KAAK,CAACyD,IAAI,CAACsH,aAAa,CAAC/G,YAAY,CAAC,CAAC,CAAC,CAAC,EAAE+G,aAAa,CAAC/G,YAAY,CAAC,CAAC,CAAC,CAAC,EAAE+G,aAAa,CAAC/G,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;MAC5G;IACF;IACA,SAAS4G,MAAMA,CAACI,KAAK,EAAE9H,QAAQ,EAAE+H,OAAO,EAAE;MACxC,OAAOA,OAAO,GAAGD,KAAK,GAAG,CAAC,IAAI9H,QAAQ,GAAG8H,KAAK,GAAG,EAAE,CAAC,IAAI9H,QAAQ,CAAC;IACnE;IACA,SAAS4H,cAAcA,CAACzJ,MAAM,EAAE;MAC9B,MAAM6J,IAAI,GAAG7J,MAAM,CAACgB,CAAC,CAAC8I,QAAQ,CAAC,CAAC,GAAG9J,MAAM,CAACiB,CAAC,CAAC6I,QAAQ,CAAC,CAAC,GAAG9J,MAAM,CAACkB,CAAC,CAAC4I,QAAQ,CAAC,CAAC;MAC5E,IAAIrB,WAAW,CAACoB,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;QAChC,OAAOpB,WAAW,CAACoB,IAAI,CAAC;MAC1B;MACApB,WAAW,CAACoB,IAAI,CAAC,GAAGrB,OAAO,CAAC/K,MAAM,GAAG,CAAC;MACtC+K,OAAO,CAACpG,IAAI,CAACpC,MAAM,CAACgB,CAAC,EAAEhB,MAAM,CAACiB,CAAC,EAAEjB,MAAM,CAACkB,CAAC,CAAC;MAC1C,OAAOuH,WAAW,CAACoB,IAAI,CAAC;IAC1B;IACA,SAASH,aAAaA,CAAC1H,KAAK,EAAE;MAC5B,MAAM6H,IAAI,GAAG7H,KAAK,CAACmH,CAAC,CAACW,QAAQ,CAAC,CAAC,GAAG9H,KAAK,CAACoH,CAAC,CAACU,QAAQ,CAAC,CAAC,GAAG9H,KAAK,CAACQ,CAAC,CAACsH,QAAQ,CAAC,CAAC;MACzE,IAAIpB,UAAU,CAACmB,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;QAC/B,OAAOnB,UAAU,CAACmB,IAAI,CAAC;MACzB;MACAnB,UAAU,CAACmB,IAAI,CAAC,GAAGnM,MAAM,CAACD,MAAM;MAChCC,MAAM,CAAC0E,IAAI,CAACJ,KAAK,CAAC+H,MAAM,CAAC,CAAC,CAAC;MAC3B,OAAOrB,UAAU,CAACmB,IAAI,CAAC;IACzB;IACA,SAASL,UAAUA,CAACvH,EAAE,EAAE;MACtB,MAAM4H,IAAI,GAAG5H,EAAE,CAACjB,CAAC,CAAC8I,QAAQ,CAAC,CAAC,GAAG7H,EAAE,CAAChB,CAAC,CAAC6I,QAAQ,CAAC,CAAC;MAC9C,IAAIlB,OAAO,CAACiB,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;QAC5B,OAAOjB,OAAO,CAACiB,IAAI,CAAC;MACtB;MACAjB,OAAO,CAACiB,IAAI,CAAC,GAAGlB,GAAG,CAAClL,MAAM,GAAG,CAAC;MAC9BkL,GAAG,CAACvG,IAAI,CAACH,EAAE,CAACjB,CAAC,EAAEiB,EAAE,CAAChB,CAAC,CAAC;MACpB,OAAO2H,OAAO,CAACiB,IAAI,CAAC;IACtB;IACA1B,IAAI,CAACA,IAAI,GAAG,CAAC,CAAC;IACdA,IAAI,CAACA,IAAI,CAAC3K,QAAQ,GAAGA,QAAQ;IAC7B2K,IAAI,CAACA,IAAI,CAACK,OAAO,GAAGA,OAAO;IAC3B,IAAI9K,MAAM,CAACD,MAAM,GAAG,CAAC,EACnB0K,IAAI,CAACA,IAAI,CAACzK,MAAM,GAAGA,MAAM;IAC3B,IAAIiL,GAAG,CAAClL,MAAM,GAAG,CAAC,EAChB0K,IAAI,CAACA,IAAI,CAACQ,GAAG,GAAG,CAACA,GAAG,CAAC;IACvBR,IAAI,CAACA,IAAI,CAACxJ,KAAK,GAAGA,KAAK;IACvB,OAAOwJ,IAAI;EACb;EACAlK,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIjB,QAAQ,CAAC,CAAC,CAACiH,IAAI,CAAC,IAAI,CAAC;EAClC;EACAA,IAAIA,CAAC+F,MAAM,EAAE;IACX,IAAI,CAACxM,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACE,MAAM,GAAG,EAAE;IAChB,IAAI,CAACiB,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,aAAa,GAAG,CAAC,EAAE,CAAC;IACzB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAAClB,aAAa,GAAG,EAAE;IACvB,IAAI,CAACI,WAAW,GAAG,IAAI;IACvB,IAAI,CAACF,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACS,IAAI,GAAGuL,MAAM,CAACvL,IAAI;IACvB,MAAMjB,QAAQ,GAAGwM,MAAM,CAACxM,QAAQ;IAChC,KAAK,IAAIoC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGrC,QAAQ,CAACC,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACjD,IAAI,CAACpC,QAAQ,CAAC4E,IAAI,CAAC5E,QAAQ,CAACoC,CAAC,CAAC,CAAC3B,KAAK,CAAC,CAAC,CAAC;IACzC;IACA,MAAMP,MAAM,GAAGsM,MAAM,CAACtM,MAAM;IAC5B,KAAK,IAAIkC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGnC,MAAM,CAACD,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC/C,IAAI,CAAClC,MAAM,CAAC0E,IAAI,CAAC1E,MAAM,CAACkC,CAAC,CAAC,CAAC3B,KAAK,CAAC,CAAC,CAAC;IACrC;IACA,MAAMU,KAAK,GAAGqL,MAAM,CAACrL,KAAK;IAC1B,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGlB,KAAK,CAAClB,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC9C,IAAI,CAACjB,KAAK,CAACyD,IAAI,CAACzD,KAAK,CAACiB,CAAC,CAAC,CAAC3B,KAAK,CAAC,CAAC,CAAC;IACnC;IACA,KAAK,IAAI2B,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGmK,MAAM,CAACpL,aAAa,CAACnB,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC7D,MAAMhB,aAAa,GAAGoL,MAAM,CAACpL,aAAa,CAACgB,CAAC,CAAC;MAC7C,IAAI,IAAI,CAAChB,aAAa,CAACgB,CAAC,CAAC,KAAK,KAAK,CAAC,EAAE;QACpC,IAAI,CAAChB,aAAa,CAACgB,CAAC,CAAC,GAAG,EAAE;MAC5B;MACA,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGxB,aAAa,CAACnB,MAAM,EAAE0C,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;QACtD,MAAMwI,GAAG,GAAG/J,aAAa,CAACuB,CAAC,CAAC;UAAE8F,OAAO,GAAG,EAAE;QAC1C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGwC,GAAG,CAAClL,MAAM,EAAEyI,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UAC5C,MAAMjE,EAAE,GAAG0G,GAAG,CAACzC,CAAC,CAAC;UACjBD,OAAO,CAAC7D,IAAI,CAACH,EAAE,CAAChE,KAAK,CAAC,CAAC,CAAC;QAC1B;QACA,IAAI,CAACW,aAAa,CAACgB,CAAC,CAAC,CAACwC,IAAI,CAAC6D,OAAO,CAAC;MACrC;IACF;IACA,MAAMpH,YAAY,GAAGmL,MAAM,CAACnL,YAAY;IACxC,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGhB,YAAY,CAACpB,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACrD,MAAMqK,WAAW,GAAG,CAAC,CAAC;MACtBA,WAAW,CAACxL,IAAI,GAAGI,YAAY,CAACe,CAAC,CAAC,CAACnB,IAAI;MACvC,IAAII,YAAY,CAACe,CAAC,CAAC,CAACpC,QAAQ,KAAK,KAAK,CAAC,EAAE;QACvCyM,WAAW,CAACzM,QAAQ,GAAG,EAAE;QACzB,KAAK,IAAI2C,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGvB,YAAY,CAACe,CAAC,CAAC,CAACpC,QAAQ,CAACC,MAAM,EAAE0C,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UACjE8J,WAAW,CAACzM,QAAQ,CAAC4E,IAAI,CAACvD,YAAY,CAACe,CAAC,CAAC,CAACpC,QAAQ,CAAC2C,CAAC,CAAC,CAAClC,KAAK,CAAC,CAAC,CAAC;QAChE;MACF;MACA,IAAIY,YAAY,CAACe,CAAC,CAAC,CAAC4I,OAAO,KAAK,KAAK,CAAC,EAAE;QACtCyB,WAAW,CAACzB,OAAO,GAAG,EAAE;QACxB,KAAK,IAAIrI,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGvB,YAAY,CAACe,CAAC,CAAC,CAAC4I,OAAO,CAAC/K,MAAM,EAAE0C,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UAChE8J,WAAW,CAACzB,OAAO,CAACpG,IAAI,CAACvD,YAAY,CAACe,CAAC,CAAC,CAAC4I,OAAO,CAACrI,CAAC,CAAC,CAAClC,KAAK,CAAC,CAAC,CAAC;QAC9D;MACF;MACA,IAAI,CAACY,YAAY,CAACuD,IAAI,CAAC6H,WAAW,CAAC;IACrC;IACA,MAAMnL,YAAY,GAAGkL,MAAM,CAAClL,YAAY;IACxC,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGf,YAAY,CAACrB,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACrD,MAAMsK,WAAW,GAAG,CAAC,CAAC;MACtB,IAAIpL,YAAY,CAACc,CAAC,CAAC,CAACS,aAAa,KAAK,KAAK,CAAC,EAAE;QAC5C6J,WAAW,CAAC7J,aAAa,GAAG,EAAE;QAC9B,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGtB,YAAY,CAACc,CAAC,CAAC,CAACS,aAAa,CAAC5C,MAAM,EAAE0C,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UACtE,MAAMgK,eAAe,GAAGrL,YAAY,CAACc,CAAC,CAAC,CAACS,aAAa,CAACF,CAAC,CAAC;UACxD,MAAMiK,gBAAgB,GAAG,CAAC,CAAC;UAC3BA,gBAAgB,CAAC7H,CAAC,GAAG4H,eAAe,CAAC5H,CAAC,CAACtE,KAAK,CAAC,CAAC;UAC9CmM,gBAAgB,CAAC5H,CAAC,GAAG2H,eAAe,CAAC3H,CAAC,CAACvE,KAAK,CAAC,CAAC;UAC9CmM,gBAAgB,CAAC3H,CAAC,GAAG0H,eAAe,CAAC1H,CAAC,CAACxE,KAAK,CAAC,CAAC;UAC9CiM,WAAW,CAAC7J,aAAa,CAAC+B,IAAI,CAACgI,gBAAgB,CAAC;QAClD;MACF;MACA,IAAItL,YAAY,CAACc,CAAC,CAAC,CAACiF,WAAW,KAAK,KAAK,CAAC,EAAE;QAC1CqF,WAAW,CAACrF,WAAW,GAAG,EAAE;QAC5B,KAAK,IAAI1E,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGtB,YAAY,CAACc,CAAC,CAAC,CAACiF,WAAW,CAACpH,MAAM,EAAE0C,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;UACpE+J,WAAW,CAACrF,WAAW,CAACzC,IAAI,CAACtD,YAAY,CAACc,CAAC,CAAC,CAACiF,WAAW,CAAC1E,CAAC,CAAC,CAAClC,KAAK,CAAC,CAAC,CAAC;QACtE;MACF;MACA,IAAI,CAACa,YAAY,CAACsD,IAAI,CAAC8H,WAAW,CAAC;IACrC;IACA,MAAMnL,WAAW,GAAGiL,MAAM,CAACjL,WAAW;IACtC,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGd,WAAW,CAACtB,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACpD,IAAI,CAACb,WAAW,CAACqD,IAAI,CAACrD,WAAW,CAACa,CAAC,CAAC,CAAC3B,KAAK,CAAC,CAAC,CAAC;IAC/C;IACA,MAAMe,WAAW,GAAGgL,MAAM,CAAChL,WAAW;IACtC,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGb,WAAW,CAACvB,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACpD,IAAI,CAACZ,WAAW,CAACoD,IAAI,CAACpD,WAAW,CAACY,CAAC,CAAC,CAAC3B,KAAK,CAAC,CAAC,CAAC;IAC/C;IACA,MAAMH,aAAa,GAAGkM,MAAM,CAAClM,aAAa;IAC1C,KAAK,IAAI8B,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG/B,aAAa,CAACL,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MACtD,IAAI,CAAC9B,aAAa,CAACsE,IAAI,CAACtE,aAAa,CAAC8B,CAAC,CAAC,CAAC;IAC3C;IACA,MAAM1B,WAAW,GAAG8L,MAAM,CAAC9L,WAAW;IACtC,IAAIA,WAAW,KAAK,IAAI,EAAE;MACxB,IAAI,CAACA,WAAW,GAAGA,WAAW,CAACD,KAAK,CAAC,CAAC;IACxC;IACA,MAAMD,cAAc,GAAGgM,MAAM,CAAChM,cAAc;IAC5C,IAAIA,cAAc,KAAK,IAAI,EAAE;MAC3B,IAAI,CAACA,cAAc,GAAGA,cAAc,CAACC,KAAK,CAAC,CAAC;IAC9C;IACA,IAAI,CAACgB,kBAAkB,GAAG+K,MAAM,CAAC/K,kBAAkB;IACnD,IAAI,CAACC,kBAAkB,GAAG8K,MAAM,CAAC9K,kBAAkB;IACnD,IAAI,CAACC,aAAa,GAAG6K,MAAM,CAAC7K,aAAa;IACzC,IAAI,CAACC,iBAAiB,GAAG4K,MAAM,CAAC5K,iBAAiB;IACjD,IAAI,CAACC,gBAAgB,GAAG2K,MAAM,CAAC3K,gBAAgB;IAC/C,IAAI,CAACC,uBAAuB,GAAG0K,MAAM,CAAC1K,uBAAuB;IAC7D,IAAI,CAACC,gBAAgB,GAAGyK,MAAM,CAACzK,gBAAgB;IAC/C,OAAO,IAAI;EACb;EACAnB,gBAAgBA,CAAA,EAAG;IACjB,MAAMhB,QAAQ,GAAG,IAAIiN,cAAc,CAAC,CAAC,CAACC,YAAY,CAAC,IAAI,CAAC;IACxD,MAAMnN,cAAc,GAAG,IAAIf,cAAc,CAAC,CAAC;IAC3C,MAAMmB,SAAS,GAAG,IAAIgN,YAAY,CAACnN,QAAQ,CAACI,QAAQ,CAACC,MAAM,GAAG,CAAC,CAAC;IAChEN,cAAc,CAACQ,YAAY,CAAC,UAAU,EAAE,IAAIf,eAAe,CAACW,SAAS,EAAE,CAAC,CAAC,CAACK,iBAAiB,CAACR,QAAQ,CAACI,QAAQ,CAAC,CAAC;IAC/G,IAAIJ,QAAQ,CAACoL,OAAO,CAAC/K,MAAM,GAAG,CAAC,EAAE;MAC/B,MAAM+K,OAAO,GAAG,IAAI+B,YAAY,CAACnN,QAAQ,CAACoL,OAAO,CAAC/K,MAAM,GAAG,CAAC,CAAC;MAC7DN,cAAc,CAACQ,YAAY,CAAC,QAAQ,EAAE,IAAIf,eAAe,CAAC4L,OAAO,EAAE,CAAC,CAAC,CAAC5K,iBAAiB,CAACR,QAAQ,CAACoL,OAAO,CAAC,CAAC;IAC5G;IACA,IAAIpL,QAAQ,CAACM,MAAM,CAACD,MAAM,GAAG,CAAC,EAAE;MAC9B,MAAMC,MAAM,GAAG,IAAI6M,YAAY,CAACnN,QAAQ,CAACM,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC;MAC3DN,cAAc,CAACQ,YAAY,CAAC,OAAO,EAAE,IAAIf,eAAe,CAACc,MAAM,EAAE,CAAC,CAAC,CAACG,eAAe,CAACT,QAAQ,CAACM,MAAM,CAAC,CAAC;IACvG;IACA,IAAIN,QAAQ,CAACuL,GAAG,CAAClL,MAAM,GAAG,CAAC,EAAE;MAC3B,MAAMkL,GAAG,GAAG,IAAI4B,YAAY,CAACnN,QAAQ,CAACuL,GAAG,CAAClL,MAAM,GAAG,CAAC,CAAC;MACrDN,cAAc,CAACQ,YAAY,CAAC,IAAI,EAAE,IAAIf,eAAe,CAAC+L,GAAG,EAAE,CAAC,CAAC,CAAC6B,iBAAiB,CAACpN,QAAQ,CAACuL,GAAG,CAAC,CAAC;IAChG;IACA,IAAIvL,QAAQ,CAAC4I,IAAI,CAACvI,MAAM,GAAG,CAAC,EAAE;MAC5B,MAAMuI,IAAI,GAAG,IAAIuE,YAAY,CAACnN,QAAQ,CAAC4I,IAAI,CAACvI,MAAM,GAAG,CAAC,CAAC;MACvDN,cAAc,CAACQ,YAAY,CAAC,KAAK,EAAE,IAAIf,eAAe,CAACoJ,IAAI,EAAE,CAAC,CAAC,CAACwE,iBAAiB,CAACpN,QAAQ,CAAC4I,IAAI,CAAC,CAAC;IACnG;IACA7I,cAAc,CAAC0F,MAAM,GAAGzF,QAAQ,CAACyF,MAAM;IACvC,KAAK,IAAIpE,IAAI,IAAIrB,QAAQ,CAACyB,YAAY,EAAE;MACtC,MAAM4L,KAAK,GAAG,EAAE;MAChB,MAAM5L,YAAY,GAAGzB,QAAQ,CAACyB,YAAY,CAACJ,IAAI,CAAC;MAChD,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAE4H,CAAC,GAAG3I,YAAY,CAACpB,MAAM,EAAEmC,CAAC,GAAG4H,CAAC,EAAE5H,CAAC,EAAE,EAAE;QACnD,MAAMqK,WAAW,GAAGpL,YAAY,CAACe,CAAC,CAAC;QACnC,MAAM8K,SAAS,GAAG,IAAIrO,sBAAsB,CAAC4N,WAAW,CAAC9B,IAAI,CAAC1K,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;QAC5EiN,SAAS,CAACjM,IAAI,GAAGwL,WAAW,CAACxL,IAAI;QACjCgM,KAAK,CAACrI,IAAI,CAACsI,SAAS,CAAC9M,iBAAiB,CAACqM,WAAW,CAAC9B,IAAI,CAAC,CAAC;MAC3D;MACAhL,cAAc,CAACwN,eAAe,CAAClM,IAAI,CAAC,GAAGgM,KAAK;IAC9C;IACA,IAAIrN,QAAQ,CAAC4B,WAAW,CAACvB,MAAM,GAAG,CAAC,EAAE;MACnC,MAAMuB,WAAW,GAAG,IAAI3C,sBAAsB,CAACe,QAAQ,CAAC4B,WAAW,CAACvB,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;MAClFN,cAAc,CAACQ,YAAY,CAAC,WAAW,EAAEqB,WAAW,CAAC4L,iBAAiB,CAACxN,QAAQ,CAAC4B,WAAW,CAAC,CAAC;IAC/F;IACA,IAAI5B,QAAQ,CAAC2B,WAAW,CAACtB,MAAM,GAAG,CAAC,EAAE;MACnC,MAAMsB,WAAW,GAAG,IAAI1C,sBAAsB,CAACe,QAAQ,CAAC2B,WAAW,CAACtB,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;MAClFN,cAAc,CAACQ,YAAY,CAAC,YAAY,EAAEoB,WAAW,CAAC6L,iBAAiB,CAACxN,QAAQ,CAAC2B,WAAW,CAAC,CAAC;IAChG;IACA,IAAI3B,QAAQ,CAACY,cAAc,KAAK,IAAI,EAAE;MACpCb,cAAc,CAACa,cAAc,GAAGZ,QAAQ,CAACY,cAAc,CAACC,KAAK,CAAC,CAAC;IACjE;IACA,IAAIb,QAAQ,CAACc,WAAW,KAAK,IAAI,EAAE;MACjCf,cAAc,CAACe,WAAW,GAAGd,QAAQ,CAACc,WAAW,CAACD,KAAK,CAAC,CAAC;IAC3D;IACA,OAAOd,cAAc;EACvB;EACA0N,eAAeA,CAAA,EAAG;IAChB/I,OAAO,CAACC,KAAK,CAAC,sDAAsD,CAAC;EACvE;EACA+I,oBAAoBA,CAAA,EAAG;IACrBhJ,OAAO,CAACC,KAAK,CACX,0GACF,CAAC;EACH;EACAgJ,WAAWA,CAACtL,MAAM,EAAE;IAClBqC,OAAO,CAACkJ,IAAI,CAAC,qEAAqE,CAAC;IACnF,OAAO,IAAI,CAACxL,YAAY,CAACC,MAAM,CAAC;EAClC;EACAwL,OAAOA,CAAA,EAAG;IACR,IAAI,CAACC,aAAa,CAAC;MAAExM,IAAI,EAAE;IAAU,CAAC,CAAC;EACzC;AACF;AACA,MAAM2L,cAAc,CAAC;EACnBhM,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACb,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACgL,OAAO,GAAG,EAAE;IACjB,IAAI,CAAC9K,MAAM,GAAG,EAAE;IAChB,IAAI,CAACiL,GAAG,GAAG,EAAE;IACb,IAAI,CAAC3C,IAAI,GAAG,EAAE;IACd,IAAI,CAACnD,MAAM,GAAG,EAAE;IAChB,IAAI,CAAChE,YAAY,GAAG,CAAC,CAAC;IACtB,IAAI,CAACE,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACd,WAAW,GAAG,IAAI;IACvB,IAAI,CAACF,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACkB,kBAAkB,GAAG,KAAK;IAC/B,IAAI,CAACE,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACF,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACI,gBAAgB,GAAG,KAAK;EAC/B;EACA4L,aAAaA,CAAC/N,QAAQ,EAAE;IACtB,MAAMyF,MAAM,GAAG,EAAE;IACjB,IAAIC,KAAK,EAAElD,CAAC;IACZ,IAAI8C,aAAa,GAAG,KAAK,CAAC;IAC1B,MAAM/D,KAAK,GAAGvB,QAAQ,CAACuB,KAAK;IAC5B,KAAKiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,KAAK,CAAClB,MAAM,EAAEmC,CAAC,EAAE,EAAE;MACjC,MAAMG,IAAI,GAAGpB,KAAK,CAACiB,CAAC,CAAC;MACrB,IAAIG,IAAI,CAAC2C,aAAa,KAAKA,aAAa,EAAE;QACxCA,aAAa,GAAG3C,IAAI,CAAC2C,aAAa;QAClC,IAAII,KAAK,KAAK,KAAK,CAAC,EAAE;UACpBA,KAAK,CAACX,KAAK,GAAGvC,CAAC,GAAG,CAAC,GAAGkD,KAAK,CAACC,KAAK;UACjCF,MAAM,CAACT,IAAI,CAACU,KAAK,CAAC;QACpB;QACAA,KAAK,GAAG;UACNC,KAAK,EAAEnD,CAAC,GAAG,CAAC;UACZ8C;QACF,CAAC;MACH;IACF;IACA,IAAII,KAAK,KAAK,KAAK,CAAC,EAAE;MACpBA,KAAK,CAACX,KAAK,GAAGvC,CAAC,GAAG,CAAC,GAAGkD,KAAK,CAACC,KAAK;MACjCF,MAAM,CAACT,IAAI,CAACU,KAAK,CAAC;IACpB;IACA,IAAI,CAACD,MAAM,GAAGA,MAAM;EACtB;EACAyH,YAAYA,CAAClN,QAAQ,EAAE;IACrB,MAAMuB,KAAK,GAAGvB,QAAQ,CAACuB,KAAK;IAC5B,MAAMnB,QAAQ,GAAGJ,QAAQ,CAACI,QAAQ;IAClC,MAAMoB,aAAa,GAAGxB,QAAQ,CAACwB,aAAa;IAC5C,MAAMmK,eAAe,GAAGnK,aAAa,CAAC,CAAC,CAAC,IAAIA,aAAa,CAAC,CAAC,CAAC,CAACnB,MAAM,GAAG,CAAC;IACvE,MAAM2N,gBAAgB,GAAGxM,aAAa,CAAC,CAAC,CAAC,IAAIA,aAAa,CAAC,CAAC,CAAC,CAACnB,MAAM,GAAG,CAAC;IACxE,MAAMoB,YAAY,GAAGzB,QAAQ,CAACyB,YAAY;IAC1C,MAAMwM,kBAAkB,GAAGxM,YAAY,CAACpB,MAAM;IAC9C,IAAI6N,oBAAoB;IACxB,IAAID,kBAAkB,GAAG,CAAC,EAAE;MAC1BC,oBAAoB,GAAG,EAAE;MACzB,KAAK,IAAI1L,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyL,kBAAkB,EAAEzL,CAAC,EAAE,EAAE;QAC3C0L,oBAAoB,CAAC1L,CAAC,CAAC,GAAG;UACxBnB,IAAI,EAAEI,YAAY,CAACe,CAAC,CAAC,CAACnB,IAAI;UAC1B0J,IAAI,EAAE;QACR,CAAC;MACH;MACA,IAAI,CAACtJ,YAAY,CAACgD,QAAQ,GAAGyJ,oBAAoB;IACnD;IACA,MAAMxM,YAAY,GAAG1B,QAAQ,CAAC0B,YAAY;IAC1C,MAAMyM,kBAAkB,GAAGzM,YAAY,CAACrB,MAAM;IAC9C,IAAI+N,kBAAkB;IACtB,IAAID,kBAAkB,GAAG,CAAC,EAAE;MAC1BC,kBAAkB,GAAG,EAAE;MACvB,KAAK,IAAI5L,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2L,kBAAkB,EAAE3L,CAAC,EAAE,EAAE;QAC3C4L,kBAAkB,CAAC5L,CAAC,CAAC,GAAG;UACtBnB,IAAI,EAAEK,YAAY,CAACc,CAAC,CAAC,CAACnB,IAAI;UAC1B0J,IAAI,EAAE;QACR,CAAC;MACH;MACA,IAAI,CAACtJ,YAAY,CAACmB,MAAM,GAAGwL,kBAAkB;IAC/C;IACA,MAAMxM,WAAW,GAAG5B,QAAQ,CAAC4B,WAAW;IACxC,MAAMD,WAAW,GAAG3B,QAAQ,CAAC2B,WAAW;IACxC,MAAM0M,cAAc,GAAGzM,WAAW,CAACvB,MAAM,KAAKD,QAAQ,CAACC,MAAM;IAC7D,MAAMiO,cAAc,GAAG3M,WAAW,CAACtB,MAAM,KAAKD,QAAQ,CAACC,MAAM;IAC7D,IAAID,QAAQ,CAACC,MAAM,GAAG,CAAC,IAAIkB,KAAK,CAAClB,MAAM,KAAK,CAAC,EAAE;MAC7CqE,OAAO,CAACC,KAAK,CAAC,8DAA8D,CAAC;IAC/E;IACA,KAAK,IAAInC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,KAAK,CAAClB,MAAM,EAAEmC,CAAC,EAAE,EAAE;MACrC,MAAMG,IAAI,GAAGpB,KAAK,CAACiB,CAAC,CAAC;MACrB,IAAI,CAACpC,QAAQ,CAAC4E,IAAI,CAAC5E,QAAQ,CAACuC,IAAI,CAACwC,CAAC,CAAC,EAAE/E,QAAQ,CAACuC,IAAI,CAACyC,CAAC,CAAC,EAAEhF,QAAQ,CAACuC,IAAI,CAAC0C,CAAC,CAAC,CAAC;MACxE,MAAMpC,aAAa,GAAGN,IAAI,CAACM,aAAa;MACxC,IAAIA,aAAa,CAAC5C,MAAM,KAAK,CAAC,EAAE;QAC9B,IAAI,CAAC+K,OAAO,CAACpG,IAAI,CAAC/B,aAAa,CAAC,CAAC,CAAC,EAAEA,aAAa,CAAC,CAAC,CAAC,EAAEA,aAAa,CAAC,CAAC,CAAC,CAAC;MACzE,CAAC,MAAM;QACL,MAAML,MAAM,GAAGD,IAAI,CAACC,MAAM;QAC1B,IAAI,CAACwI,OAAO,CAACpG,IAAI,CAACpC,MAAM,EAAEA,MAAM,EAAEA,MAAM,CAAC;MAC3C;MACA,MAAM2C,YAAY,GAAG5C,IAAI,CAAC4C,YAAY;MACtC,IAAIA,YAAY,CAAClF,MAAM,KAAK,CAAC,EAAE;QAC7B,IAAI,CAACC,MAAM,CAAC0E,IAAI,CAACO,YAAY,CAAC,CAAC,CAAC,EAAEA,YAAY,CAAC,CAAC,CAAC,EAAEA,YAAY,CAAC,CAAC,CAAC,CAAC;MACrE,CAAC,MAAM;QACL,MAAMX,KAAK,GAAGjC,IAAI,CAACiC,KAAK;QACxB,IAAI,CAACtE,MAAM,CAAC0E,IAAI,CAACJ,KAAK,EAAEA,KAAK,EAAEA,KAAK,CAAC;MACvC;MACA,IAAI+G,eAAe,KAAK,IAAI,EAAE;QAC5B,MAAM4C,SAAS,GAAG/M,aAAa,CAAC,CAAC,CAAC,CAACgB,CAAC,CAAC;QACrC,IAAI+L,SAAS,KAAK,KAAK,CAAC,EAAE;UACxB,IAAI,CAAChD,GAAG,CAACvG,IAAI,CAACuJ,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;QACzD,CAAC,MAAM;UACL7J,OAAO,CAACkJ,IAAI,CAAC,0DAA0D,EAAEpL,CAAC,CAAC;UAC3E,IAAI,CAAC+I,GAAG,CAACvG,IAAI,CAAC,IAAI3F,OAAO,CAAC,CAAC,EAAE,IAAIA,OAAO,CAAC,CAAC,EAAE,IAAIA,OAAO,CAAC,CAAC,CAAC;QAC5D;MACF;MACA,IAAI2O,gBAAgB,KAAK,IAAI,EAAE;QAC7B,MAAMO,SAAS,GAAG/M,aAAa,CAAC,CAAC,CAAC,CAACgB,CAAC,CAAC;QACrC,IAAI+L,SAAS,KAAK,KAAK,CAAC,EAAE;UACxB,IAAI,CAAC3F,IAAI,CAAC5D,IAAI,CAACuJ,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;QAC1D,CAAC,MAAM;UACL7J,OAAO,CAACkJ,IAAI,CAAC,2DAA2D,EAAEpL,CAAC,CAAC;UAC5E,IAAI,CAACoG,IAAI,CAAC5D,IAAI,CAAC,IAAI3F,OAAO,CAAC,CAAC,EAAE,IAAIA,OAAO,CAAC,CAAC,EAAE,IAAIA,OAAO,CAAC,CAAC,CAAC;QAC7D;MACF;MACA,KAAK,IAAI0D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkL,kBAAkB,EAAElL,CAAC,EAAE,EAAE;QAC3C,MAAM8J,WAAW,GAAGpL,YAAY,CAACsB,CAAC,CAAC,CAAC3C,QAAQ;QAC5C8N,oBAAoB,CAACnL,CAAC,CAAC,CAACgI,IAAI,CAAC/F,IAAI,CAAC6H,WAAW,CAAClK,IAAI,CAACwC,CAAC,CAAC,EAAE0H,WAAW,CAAClK,IAAI,CAACyC,CAAC,CAAC,EAAEyH,WAAW,CAAClK,IAAI,CAAC0C,CAAC,CAAC,CAAC;MAClG;MACA,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoL,kBAAkB,EAAEpL,CAAC,EAAE,EAAE;QAC3C,MAAM+J,WAAW,GAAGpL,YAAY,CAACqB,CAAC,CAAC,CAACE,aAAa,CAACT,CAAC,CAAC;QACpD4L,kBAAkB,CAACrL,CAAC,CAAC,CAACgI,IAAI,CAAC/F,IAAI,CAAC8H,WAAW,CAAC3H,CAAC,EAAE2H,WAAW,CAAC1H,CAAC,EAAE0H,WAAW,CAACzH,CAAC,CAAC;MAC9E;MACA,IAAIgJ,cAAc,EAAE;QAClB,IAAI,CAACzM,WAAW,CAACoD,IAAI,CAACpD,WAAW,CAACe,IAAI,CAACwC,CAAC,CAAC,EAAEvD,WAAW,CAACe,IAAI,CAACyC,CAAC,CAAC,EAAExD,WAAW,CAACe,IAAI,CAAC0C,CAAC,CAAC,CAAC;MACtF;MACA,IAAIiJ,cAAc,EAAE;QAClB,IAAI,CAAC3M,WAAW,CAACqD,IAAI,CAACrD,WAAW,CAACgB,IAAI,CAACwC,CAAC,CAAC,EAAExD,WAAW,CAACgB,IAAI,CAACyC,CAAC,CAAC,EAAEzD,WAAW,CAACgB,IAAI,CAAC0C,CAAC,CAAC,CAAC;MACtF;IACF;IACA,IAAI,CAAC0I,aAAa,CAAC/N,QAAQ,CAAC;IAC5B,IAAI,CAAC8B,kBAAkB,GAAG9B,QAAQ,CAAC8B,kBAAkB;IACrD,IAAI,CAACE,iBAAiB,GAAGhC,QAAQ,CAACgC,iBAAiB;IACnD,IAAI,CAACC,gBAAgB,GAAGjC,QAAQ,CAACiC,gBAAgB;IACjD,IAAI,CAACF,aAAa,GAAG/B,QAAQ,CAAC+B,aAAa;IAC3C,IAAI,CAACI,gBAAgB,GAAGnC,QAAQ,CAACmC,gBAAgB;IACjD,IAAInC,QAAQ,CAACY,cAAc,KAAK,IAAI,EAAE;MACpC,IAAI,CAACA,cAAc,GAAGZ,QAAQ,CAACY,cAAc,CAACC,KAAK,CAAC,CAAC;IACvD;IACA,IAAIb,QAAQ,CAACc,WAAW,KAAK,IAAI,EAAE;MACjC,IAAI,CAACA,WAAW,GAAGd,QAAQ,CAACc,WAAW,CAACD,KAAK,CAAC,CAAC;IACjD;IACA,OAAO,IAAI;EACb;AACF;AACA,MAAM2E,KAAK,CAAC;EACVvE,WAAWA,CAACkE,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEzC,MAAM,EAAEgC,KAAK,EAAEU,aAAa,GAAG,CAAC,EAAE;IACrD,IAAI,CAACH,CAAC,GAAGA,CAAC;IACV,IAAI,CAACC,CAAC,GAAGA,CAAC;IACV,IAAI,CAACC,CAAC,GAAGA,CAAC;IACV,IAAI,CAACzC,MAAM,GAAGA,MAAM,IAAIA,MAAM,CAAC4L,SAAS,GAAG5L,MAAM,GAAG,IAAI9D,OAAO,CAAC,CAAC;IACjE,IAAI,CAACmE,aAAa,GAAG+D,KAAK,CAACyH,OAAO,CAAC7L,MAAM,CAAC,GAAGA,MAAM,GAAG,EAAE;IACxD,IAAI,CAACgC,KAAK,GAAGA,KAAK,IAAIA,KAAK,CAAC8J,OAAO,GAAG9J,KAAK,GAAG,IAAIxF,KAAK,CAAC,CAAC;IACzD,IAAI,CAACmG,YAAY,GAAGyB,KAAK,CAACyH,OAAO,CAAC7J,KAAK,CAAC,GAAGA,KAAK,GAAG,EAAE;IACrD,IAAI,CAACU,aAAa,GAAGA,aAAa;EACpC;EACAzE,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI,IAAI,CAACI,WAAW,CAAC,CAAC,CAAC4F,IAAI,CAAC,IAAI,CAAC;EAC1C;EACAA,IAAIA,CAAC+F,MAAM,EAAE;IACX,IAAI,CAACzH,CAAC,GAAGyH,MAAM,CAACzH,CAAC;IACjB,IAAI,CAACC,CAAC,GAAGwH,MAAM,CAACxH,CAAC;IACjB,IAAI,CAACC,CAAC,GAAGuH,MAAM,CAACvH,CAAC;IACjB,IAAI,CAACzC,MAAM,CAACiE,IAAI,CAAC+F,MAAM,CAAChK,MAAM,CAAC;IAC/B,IAAI,CAACgC,KAAK,CAACiC,IAAI,CAAC+F,MAAM,CAAChI,KAAK,CAAC;IAC7B,IAAI,CAACU,aAAa,GAAGsH,MAAM,CAACtH,aAAa;IACzC,KAAK,IAAI9C,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGmK,MAAM,CAAC3J,aAAa,CAAC5C,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC7D,IAAI,CAACS,aAAa,CAACT,CAAC,CAAC,GAAGoK,MAAM,CAAC3J,aAAa,CAACT,CAAC,CAAC,CAAC3B,KAAK,CAAC,CAAC;IACzD;IACA,KAAK,IAAI2B,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGmK,MAAM,CAACrH,YAAY,CAAClF,MAAM,EAAEmC,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;MAC5D,IAAI,CAAC+C,YAAY,CAAC/C,CAAC,CAAC,GAAGoK,MAAM,CAACrH,YAAY,CAAC/C,CAAC,CAAC,CAAC3B,KAAK,CAAC,CAAC;IACvD;IACA,OAAO,IAAI;EACb;AACF;AACA,SACE2E,KAAK,EACL5F,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}