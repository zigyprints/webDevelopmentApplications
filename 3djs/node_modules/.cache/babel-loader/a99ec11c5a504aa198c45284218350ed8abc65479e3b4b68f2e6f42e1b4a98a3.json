{"ast":null,"code":"import { Color, REVISION, ShaderMaterial, UniformsUtils, UniformsLib, BackSide } from \"three\";\nclass OutlineEffect {\n  constructor(renderer, parameters = {}) {\n    this.enabled = true;\n    const defaultThickness = parameters.defaultThickness !== void 0 ? parameters.defaultThickness : 3e-3;\n    const defaultColor = new Color().fromArray(parameters.defaultColor !== void 0 ? parameters.defaultColor : [0, 0, 0]);\n    const defaultAlpha = parameters.defaultAlpha !== void 0 ? parameters.defaultAlpha : 1;\n    const defaultKeepAlive = parameters.defaultKeepAlive !== void 0 ? parameters.defaultKeepAlive : false;\n    const cache = {};\n    const removeThresholdCount = 60;\n    const originalMaterials = {};\n    const originalOnBeforeRenders = {};\n    const uniformsOutline = {\n      outlineThickness: {\n        value: defaultThickness\n      },\n      outlineColor: {\n        value: defaultColor\n      },\n      outlineAlpha: {\n        value: defaultAlpha\n      }\n    };\n    const vertexShader = [\"#include <common>\", \"#include <uv_pars_vertex>\", \"#include <displacementmap_pars_vertex>\", \"#include <fog_pars_vertex>\", \"#include <morphtarget_pars_vertex>\", \"#include <skinning_pars_vertex>\", \"#include <logdepthbuf_pars_vertex>\", \"#include <clipping_planes_pars_vertex>\", \"uniform float outlineThickness;\", \"vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {\", \"\tfloat thickness = outlineThickness;\", \"\tconst float ratio = 1.0;\",\n    // TODO: support outline thickness ratio for each vertex\n    \"\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );\",\n    // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n    \"\tvec4 norm = normalize( pos - pos2 );\", \"\treturn pos + norm * thickness * pos.w * ratio;\", \"}\", \"void main() {\", \"\t#include <uv_vertex>\", \"\t#include <beginnormal_vertex>\", \"\t#include <morphnormal_vertex>\", \"\t#include <skinbase_vertex>\", \"\t#include <skinnormal_vertex>\", \"\t#include <begin_vertex>\", \"\t#include <morphtarget_vertex>\", \"\t#include <skinning_vertex>\", \"\t#include <displacementmap_vertex>\", \"\t#include <project_vertex>\", \"\tvec3 outlineNormal = - objectNormal;\",\n    // the outline material is always rendered with BackSide\n    \"\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );\", \"\t#include <logdepthbuf_vertex>\", \"\t#include <clipping_planes_vertex>\", \"\t#include <fog_vertex>\", \"}\"].join(\"\\n\");\n    const fragmentShader = [\"#include <common>\", \"#include <fog_pars_fragment>\", \"#include <logdepthbuf_pars_fragment>\", \"#include <clipping_planes_pars_fragment>\", \"uniform vec3 outlineColor;\", \"uniform float outlineAlpha;\", \"void main() {\", \"\t#include <clipping_planes_fragment>\", \"\t#include <logdepthbuf_fragment>\", \"\tgl_FragColor = vec4( outlineColor, outlineAlpha );\", \"\t#include <tonemapping_fragment>\", `\t#include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>`, \"\t#include <fog_fragment>\", \"\t#include <premultiplied_alpha_fragment>\", \"}\"].join(\"\\n\");\n    function createMaterial() {\n      return new ShaderMaterial({\n        type: \"OutlineEffect\",\n        uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], UniformsLib[\"displacementmap\"], uniformsOutline]),\n        vertexShader,\n        fragmentShader,\n        side: BackSide\n      });\n    }\n    function getOutlineMaterialFromCache(originalMaterial) {\n      let data = cache[originalMaterial.uuid];\n      if (data === void 0) {\n        data = {\n          material: createMaterial(),\n          used: true,\n          keepAlive: defaultKeepAlive,\n          count: 0\n        };\n        cache[originalMaterial.uuid] = data;\n      }\n      data.used = true;\n      return data.material;\n    }\n    function getOutlineMaterial(originalMaterial) {\n      const outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n      originalMaterials[outlineMaterial.uuid] = originalMaterial;\n      updateOutlineMaterial(outlineMaterial, originalMaterial);\n      return outlineMaterial;\n    }\n    function isCompatible(object) {\n      const geometry = object.geometry;\n      const hasNormals = geometry !== void 0 && geometry.attributes.normal !== void 0;\n      return object.isMesh === true && object.material !== void 0 && hasNormals === true;\n    }\n    function setOutlineMaterial(object) {\n      if (isCompatible(object) === false) return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = getOutlineMaterial(object.material[i]);\n        }\n      } else {\n        object.material = getOutlineMaterial(object.material);\n      }\n      originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n      object.onBeforeRender = onBeforeRender;\n    }\n    function restoreOriginalMaterial(object) {\n      if (isCompatible(object) === false) return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = originalMaterials[object.material[i].uuid];\n        }\n      } else {\n        object.material = originalMaterials[object.material.uuid];\n      }\n      object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n    }\n    function onBeforeRender(renderer2, scene, camera, geometry, material) {\n      const originalMaterial = originalMaterials[material.uuid];\n      if (originalMaterial === void 0) return;\n      updateUniforms(material, originalMaterial);\n    }\n    function updateUniforms(material, originalMaterial) {\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n      if (outlineParameters !== void 0) {\n        if (outlineParameters.thickness !== void 0) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n        if (outlineParameters.color !== void 0) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n        if (outlineParameters.alpha !== void 0) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n      }\n      if (originalMaterial.displacementMap) {\n        material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n        material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n        material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n      }\n    }\n    function updateOutlineMaterial(material, originalMaterial) {\n      if (material.name === \"invisible\") return;\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.fog = originalMaterial.fog;\n      material.toneMapped = originalMaterial.toneMapped;\n      material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n      material.displacementMap = originalMaterial.displacementMap;\n      if (outlineParameters !== void 0) {\n        if (originalMaterial.visible === false) {\n          material.visible = false;\n        } else {\n          material.visible = outlineParameters.visible !== void 0 ? outlineParameters.visible : true;\n        }\n        material.transparent = outlineParameters.alpha !== void 0 && outlineParameters.alpha < 1 ? true : originalMaterial.transparent;\n        if (outlineParameters.keepAlive !== void 0) cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n      } else {\n        material.transparent = originalMaterial.transparent;\n        material.visible = originalMaterial.visible;\n      }\n      if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;\n      if (originalMaterial.clippingPlanes) {\n        material.clipping = true;\n        material.clippingPlanes = originalMaterial.clippingPlanes;\n        material.clipIntersection = originalMaterial.clipIntersection;\n        material.clipShadows = originalMaterial.clipShadows;\n      }\n      material.version = originalMaterial.version;\n    }\n    function cleanupCache() {\n      let keys;\n      keys = Object.keys(originalMaterials);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalMaterials[keys[i]] = void 0;\n      }\n      keys = Object.keys(originalOnBeforeRenders);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalOnBeforeRenders[keys[i]] = void 0;\n      }\n      keys = Object.keys(cache);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const key = keys[i];\n        if (cache[key].used === false) {\n          cache[key].count++;\n          if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n            delete cache[key];\n          }\n        } else {\n          cache[key].used = false;\n          cache[key].count = 0;\n        }\n      }\n    }\n    this.render = function (scene, camera) {\n      if (this.enabled === false) {\n        renderer.render(scene, camera);\n        return;\n      }\n      const currentAutoClear = renderer.autoClear;\n      renderer.autoClear = this.autoClear;\n      renderer.render(scene, camera);\n      renderer.autoClear = currentAutoClear;\n      this.renderOutline(scene, camera);\n    };\n    this.renderOutline = function (scene, camera) {\n      const currentAutoClear = renderer.autoClear;\n      const currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n      const currentSceneBackground = scene.background;\n      const currentShadowMapEnabled = renderer.shadowMap.enabled;\n      scene.matrixWorldAutoUpdate = false;\n      scene.background = null;\n      renderer.autoClear = false;\n      renderer.shadowMap.enabled = false;\n      scene.traverse(setOutlineMaterial);\n      renderer.render(scene, camera);\n      scene.traverse(restoreOriginalMaterial);\n      cleanupCache();\n      scene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n      scene.background = currentSceneBackground;\n      renderer.autoClear = currentAutoClear;\n      renderer.shadowMap.enabled = currentShadowMapEnabled;\n    };\n    this.autoClear = renderer.autoClear;\n    this.domElement = renderer.domElement;\n    this.shadowMap = renderer.shadowMap;\n    this.clear = function (color, depth, stencil) {\n      renderer.clear(color, depth, stencil);\n    };\n    this.getPixelRatio = function () {\n      return renderer.getPixelRatio();\n    };\n    this.setPixelRatio = function (value) {\n      renderer.setPixelRatio(value);\n    };\n    this.getSize = function (target) {\n      return renderer.getSize(target);\n    };\n    this.setSize = function (width, height, updateStyle) {\n      renderer.setSize(width, height, updateStyle);\n    };\n    this.setViewport = function (x, y, width, height) {\n      renderer.setViewport(x, y, width, height);\n    };\n    this.setScissor = function (x, y, width, height) {\n      renderer.setScissor(x, y, width, height);\n    };\n    this.setScissorTest = function (boolean) {\n      renderer.setScissorTest(boolean);\n    };\n    this.setRenderTarget = function (renderTarget) {\n      renderer.setRenderTarget(renderTarget);\n    };\n  }\n}\nexport { OutlineEffect };","map":{"version":3,"names":["Color","REVISION","ShaderMaterial","UniformsUtils","UniformsLib","BackSide","OutlineEffect","constructor","renderer","parameters","enabled","defaultThickness","defaultColor","fromArray","defaultAlpha","defaultKeepAlive","cache","removeThresholdCount","originalMaterials","originalOnBeforeRenders","uniformsOutline","outlineThickness","value","outlineColor","outlineAlpha","vertexShader","join","fragmentShader","parseInt","replace","createMaterial","type","uniforms","merge","side","getOutlineMaterialFromCache","originalMaterial","data","uuid","material","used","keepAlive","count","getOutlineMaterial","outlineMaterial","updateOutlineMaterial","isCompatible","object","geometry","hasNormals","attributes","normal","isMesh","setOutlineMaterial","Array","isArray","i","il","length","onBeforeRender","restoreOriginalMaterial","renderer2","scene","camera","updateUniforms","outlineParameters","userData","opacity","thickness","color","alpha","displacementMap","displacementScale","displacementBias","name","fog","toneMapped","premultipliedAlpha","visible","transparent","wireframe","depthTest","clippingPlanes","clipping","clipIntersection","clipShadows","version","cleanupCache","keys","Object","key","render","currentAutoClear","autoClear","renderOutline","currentSceneAutoUpdate","matrixWorldAutoUpdate","currentSceneBackground","background","currentShadowMapEnabled","shadowMap","traverse","domElement","clear","depth","stencil","getPixelRatio","setPixelRatio","getSize","target","setSize","width","height","updateStyle","setViewport","x","y","setScissor","setScissorTest","boolean","setRenderTarget","renderTarget"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/effects/OutlineEffect.js"],"sourcesContent":["import { Color, REVISION, ShaderMaterial, UniformsUtils, UniformsLib, BackSide } from \"three\";\nclass OutlineEffect {\n  constructor(renderer, parameters = {}) {\n    this.enabled = true;\n    const defaultThickness = parameters.defaultThickness !== void 0 ? parameters.defaultThickness : 3e-3;\n    const defaultColor = new Color().fromArray(\n      parameters.defaultColor !== void 0 ? parameters.defaultColor : [0, 0, 0]\n    );\n    const defaultAlpha = parameters.defaultAlpha !== void 0 ? parameters.defaultAlpha : 1;\n    const defaultKeepAlive = parameters.defaultKeepAlive !== void 0 ? parameters.defaultKeepAlive : false;\n    const cache = {};\n    const removeThresholdCount = 60;\n    const originalMaterials = {};\n    const originalOnBeforeRenders = {};\n    const uniformsOutline = {\n      outlineThickness: { value: defaultThickness },\n      outlineColor: { value: defaultColor },\n      outlineAlpha: { value: defaultAlpha }\n    };\n    const vertexShader = [\n      \"#include <common>\",\n      \"#include <uv_pars_vertex>\",\n      \"#include <displacementmap_pars_vertex>\",\n      \"#include <fog_pars_vertex>\",\n      \"#include <morphtarget_pars_vertex>\",\n      \"#include <skinning_pars_vertex>\",\n      \"#include <logdepthbuf_pars_vertex>\",\n      \"#include <clipping_planes_pars_vertex>\",\n      \"uniform float outlineThickness;\",\n      \"vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {\",\n      \"\tfloat thickness = outlineThickness;\",\n      \"\tconst float ratio = 1.0;\",\n      // TODO: support outline thickness ratio for each vertex\n      \"\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );\",\n      // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n      \"\tvec4 norm = normalize( pos - pos2 );\",\n      \"\treturn pos + norm * thickness * pos.w * ratio;\",\n      \"}\",\n      \"void main() {\",\n      \"\t#include <uv_vertex>\",\n      \"\t#include <beginnormal_vertex>\",\n      \"\t#include <morphnormal_vertex>\",\n      \"\t#include <skinbase_vertex>\",\n      \"\t#include <skinnormal_vertex>\",\n      \"\t#include <begin_vertex>\",\n      \"\t#include <morphtarget_vertex>\",\n      \"\t#include <skinning_vertex>\",\n      \"\t#include <displacementmap_vertex>\",\n      \"\t#include <project_vertex>\",\n      \"\tvec3 outlineNormal = - objectNormal;\",\n      // the outline material is always rendered with BackSide\n      \"\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );\",\n      \"\t#include <logdepthbuf_vertex>\",\n      \"\t#include <clipping_planes_vertex>\",\n      \"\t#include <fog_vertex>\",\n      \"}\"\n    ].join(\"\\n\");\n    const fragmentShader = [\n      \"#include <common>\",\n      \"#include <fog_pars_fragment>\",\n      \"#include <logdepthbuf_pars_fragment>\",\n      \"#include <clipping_planes_pars_fragment>\",\n      \"uniform vec3 outlineColor;\",\n      \"uniform float outlineAlpha;\",\n      \"void main() {\",\n      \"\t#include <clipping_planes_fragment>\",\n      \"\t#include <logdepthbuf_fragment>\",\n      \"\tgl_FragColor = vec4( outlineColor, outlineAlpha );\",\n      \"\t#include <tonemapping_fragment>\",\n      `\t#include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>`,\n      \"\t#include <fog_fragment>\",\n      \"\t#include <premultiplied_alpha_fragment>\",\n      \"}\"\n    ].join(\"\\n\");\n    function createMaterial() {\n      return new ShaderMaterial({\n        type: \"OutlineEffect\",\n        uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], UniformsLib[\"displacementmap\"], uniformsOutline]),\n        vertexShader,\n        fragmentShader,\n        side: BackSide\n      });\n    }\n    function getOutlineMaterialFromCache(originalMaterial) {\n      let data = cache[originalMaterial.uuid];\n      if (data === void 0) {\n        data = {\n          material: createMaterial(),\n          used: true,\n          keepAlive: defaultKeepAlive,\n          count: 0\n        };\n        cache[originalMaterial.uuid] = data;\n      }\n      data.used = true;\n      return data.material;\n    }\n    function getOutlineMaterial(originalMaterial) {\n      const outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n      originalMaterials[outlineMaterial.uuid] = originalMaterial;\n      updateOutlineMaterial(outlineMaterial, originalMaterial);\n      return outlineMaterial;\n    }\n    function isCompatible(object) {\n      const geometry = object.geometry;\n      const hasNormals = geometry !== void 0 && geometry.attributes.normal !== void 0;\n      return object.isMesh === true && object.material !== void 0 && hasNormals === true;\n    }\n    function setOutlineMaterial(object) {\n      if (isCompatible(object) === false)\n        return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = getOutlineMaterial(object.material[i]);\n        }\n      } else {\n        object.material = getOutlineMaterial(object.material);\n      }\n      originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n      object.onBeforeRender = onBeforeRender;\n    }\n    function restoreOriginalMaterial(object) {\n      if (isCompatible(object) === false)\n        return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = originalMaterials[object.material[i].uuid];\n        }\n      } else {\n        object.material = originalMaterials[object.material.uuid];\n      }\n      object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n    }\n    function onBeforeRender(renderer2, scene, camera, geometry, material) {\n      const originalMaterial = originalMaterials[material.uuid];\n      if (originalMaterial === void 0)\n        return;\n      updateUniforms(material, originalMaterial);\n    }\n    function updateUniforms(material, originalMaterial) {\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n      if (outlineParameters !== void 0) {\n        if (outlineParameters.thickness !== void 0)\n          material.uniforms.outlineThickness.value = outlineParameters.thickness;\n        if (outlineParameters.color !== void 0)\n          material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n        if (outlineParameters.alpha !== void 0)\n          material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n      }\n      if (originalMaterial.displacementMap) {\n        material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n        material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n        material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n      }\n    }\n    function updateOutlineMaterial(material, originalMaterial) {\n      if (material.name === \"invisible\")\n        return;\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.fog = originalMaterial.fog;\n      material.toneMapped = originalMaterial.toneMapped;\n      material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n      material.displacementMap = originalMaterial.displacementMap;\n      if (outlineParameters !== void 0) {\n        if (originalMaterial.visible === false) {\n          material.visible = false;\n        } else {\n          material.visible = outlineParameters.visible !== void 0 ? outlineParameters.visible : true;\n        }\n        material.transparent = outlineParameters.alpha !== void 0 && outlineParameters.alpha < 1 ? true : originalMaterial.transparent;\n        if (outlineParameters.keepAlive !== void 0)\n          cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n      } else {\n        material.transparent = originalMaterial.transparent;\n        material.visible = originalMaterial.visible;\n      }\n      if (originalMaterial.wireframe === true || originalMaterial.depthTest === false)\n        material.visible = false;\n      if (originalMaterial.clippingPlanes) {\n        material.clipping = true;\n        material.clippingPlanes = originalMaterial.clippingPlanes;\n        material.clipIntersection = originalMaterial.clipIntersection;\n        material.clipShadows = originalMaterial.clipShadows;\n      }\n      material.version = originalMaterial.version;\n    }\n    function cleanupCache() {\n      let keys;\n      keys = Object.keys(originalMaterials);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalMaterials[keys[i]] = void 0;\n      }\n      keys = Object.keys(originalOnBeforeRenders);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalOnBeforeRenders[keys[i]] = void 0;\n      }\n      keys = Object.keys(cache);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const key = keys[i];\n        if (cache[key].used === false) {\n          cache[key].count++;\n          if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n            delete cache[key];\n          }\n        } else {\n          cache[key].used = false;\n          cache[key].count = 0;\n        }\n      }\n    }\n    this.render = function(scene, camera) {\n      if (this.enabled === false) {\n        renderer.render(scene, camera);\n        return;\n      }\n      const currentAutoClear = renderer.autoClear;\n      renderer.autoClear = this.autoClear;\n      renderer.render(scene, camera);\n      renderer.autoClear = currentAutoClear;\n      this.renderOutline(scene, camera);\n    };\n    this.renderOutline = function(scene, camera) {\n      const currentAutoClear = renderer.autoClear;\n      const currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n      const currentSceneBackground = scene.background;\n      const currentShadowMapEnabled = renderer.shadowMap.enabled;\n      scene.matrixWorldAutoUpdate = false;\n      scene.background = null;\n      renderer.autoClear = false;\n      renderer.shadowMap.enabled = false;\n      scene.traverse(setOutlineMaterial);\n      renderer.render(scene, camera);\n      scene.traverse(restoreOriginalMaterial);\n      cleanupCache();\n      scene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n      scene.background = currentSceneBackground;\n      renderer.autoClear = currentAutoClear;\n      renderer.shadowMap.enabled = currentShadowMapEnabled;\n    };\n    this.autoClear = renderer.autoClear;\n    this.domElement = renderer.domElement;\n    this.shadowMap = renderer.shadowMap;\n    this.clear = function(color, depth, stencil) {\n      renderer.clear(color, depth, stencil);\n    };\n    this.getPixelRatio = function() {\n      return renderer.getPixelRatio();\n    };\n    this.setPixelRatio = function(value) {\n      renderer.setPixelRatio(value);\n    };\n    this.getSize = function(target) {\n      return renderer.getSize(target);\n    };\n    this.setSize = function(width, height, updateStyle) {\n      renderer.setSize(width, height, updateStyle);\n    };\n    this.setViewport = function(x, y, width, height) {\n      renderer.setViewport(x, y, width, height);\n    };\n    this.setScissor = function(x, y, width, height) {\n      renderer.setScissor(x, y, width, height);\n    };\n    this.setScissorTest = function(boolean) {\n      renderer.setScissorTest(boolean);\n    };\n    this.setRenderTarget = function(renderTarget) {\n      renderer.setRenderTarget(renderTarget);\n    };\n  }\n}\nexport {\n  OutlineEffect\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}