{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, FileLoader, ShapePath } from \"three\";\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, response => {\n      if (typeof response !== \"string\") throw new Error(\"unsupported data type\");\n      const json = JSON.parse(response);\n      const font = this.parse(json);\n      if (onLoad) onLoad(font);\n    }, onProgress, onError);\n  }\n  loadAsync(url, onProgress) {\n    return super.loadAsync(url, onProgress);\n  }\n  parse(json) {\n    return new Font(json);\n  }\n}\nclass Font {\n  constructor(data) {\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  generateShapes(text, size = 100, _options) {\n    const shapes = [];\n    const options = {\n      letterSpacing: 0,\n      lineHeight: 1,\n      ..._options\n    };\n    const paths = createPaths(text, size, this.data, options);\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n    return shapes;\n  }\n}\n__publicField(Font, \"isFont\");\n__publicField(Font, \"type\");\nfunction createPaths(text, size, data, options) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0,\n    offsetY = 0;\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs[\"?\"];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + \".\");\n    return;\n  }\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(\" \"));\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n      switch (action) {\n        case \"m\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case \"l\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case \"q\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case \"b\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return {\n    offsetX: glyph.ha * scale,\n    path\n  };\n}\nexport { Font, FontLoader };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Loader","FileLoader","ShapePath","FontLoader","constructor","manager","load","url","onLoad","onProgress","onError","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","response","Error","json","JSON","parse","font","loadAsync","Font","data","generateShapes","text","size","_options","shapes","options","letterSpacing","lineHeight","paths","createPaths","p","pl","length","Array","prototype","push","apply","toShapes","chars","from","scale","resolution","line_height","boundingBox","yMax","yMin","underlineThickness","offsetX","offsetY","i","char","ret","createPath","glyph","glyphs","console","error","familyName","x","y","cpx","cpy","cpx1","cpy1","cpx2","cpy2","o","outline","_cachedOutline","split","l","action","parseInt","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/loaders/FontLoader.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, FileLoader, ShapePath } from \"three\";\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (response) => {\n        if (typeof response !== \"string\")\n          throw new Error(\"unsupported data type\");\n        const json = JSON.parse(response);\n        const font = this.parse(json);\n        if (onLoad)\n          onLoad(font);\n      },\n      onProgress,\n      onError\n    );\n  }\n  loadAsync(url, onProgress) {\n    return super.loadAsync(url, onProgress);\n  }\n  parse(json) {\n    return new Font(json);\n  }\n}\nclass Font {\n  constructor(data) {\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  generateShapes(text, size = 100, _options) {\n    const shapes = [];\n    const options = { letterSpacing: 0, lineHeight: 1, ..._options };\n    const paths = createPaths(text, size, this.data, options);\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n    return shapes;\n  }\n}\n__publicField(Font, \"isFont\");\n__publicField(Font, \"type\");\nfunction createPaths(text, size, data, options) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0, offsetY = 0;\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs[\"?\"];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + \".\");\n    return;\n  }\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(\" \"));\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++];\n      switch (action) {\n        case \"m\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case \"l\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case \"q\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case \"b\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return { offsetX: glyph.ha * scale, path };\n}\nexport {\n  Font,\n  FontLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}