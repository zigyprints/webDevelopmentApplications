{"ast":null,"code":"import { Vector3, ShaderMaterial, UniformsUtils, UniformsLib, Color, REVISION, LineSegments, Ray, FileLoader, Matrix4, Group, BufferGeometry, BufferAttribute, Mesh, Loader, MeshStandardMaterial, LineBasicMaterial } from \"three\";\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = \"16\";\nconst MAIN_EDGE_COLOUR_CODE = \"24\";\nconst _tempVec0 = /* @__PURE__ */new Vector3();\nconst _tempVec1 = /* @__PURE__ */new Vector3();\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1\n        }\n      }]),\n      vertexShader: /* glsl */\n      `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `,\n      fragmentShader: /* glsl */\n      `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n    this.isLDrawConditionalLineMaterial = true;\n  }\n}\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n}\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n    _tempVec0.subVectors(v1, v0);\n    _tempVec1.subVectors(v2, v1);\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\nconst _ray = /* @__PURE__ */new Ray();\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  const hashMultiplier = (1 + 1e-10) * 100;\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n  const hardEdges = /* @__PURE__ */new Set();\n  const hardEdgeRays = /* @__PURE__ */new Map();\n  const halfEdgeList = {};\n  const normals = [];\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n    if (checkSubSegments) {\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info2 = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info2);\n        hardEdgeRays.set(rh2, info2);\n      }\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n      if (d0 > d1) {\n        ;\n        [d0, d1] = [d1, d0];\n      }\n      info.distances.push(d0, d1);\n    }\n  }\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1);\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n        if (hardEdgeRays.has(rayHash)) {\n          const info2 = hardEdgeRays.get(rayHash);\n          const {\n            ray,\n            distances\n          } = info2;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n          if (d0 > d1) {\n            ;\n            [d0, d1] = [d1, d0];\n          }\n          let found = false;\n          for (let i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {\n            if (d0 >= distances[i3] && d1 <= distances[i3 + 1]) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n        }\n      }\n      const info = {\n        index,\n        tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  }\n  while (true) {\n    let halfEdge = null;\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n    if (halfEdge === null) {\n      break;\n    }\n    const queue = [halfEdge];\n    while (queue.length > 0) {\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal;\n      const vertCount = vertices.length;\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next];\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal;\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          }\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n          const otherNext = (otherIndex + 1) % otherVertCount;\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n          if (sharedNormal1 === null) {\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\nfunction isPartType(type) {\n  return type === \"Part\" || type === \"Unofficial_Part\";\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === \"Subpart\";\n}\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = \" \";\n    this.lineNumber = lineNumber;\n  }\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar !== \" \" && this.currentChar !== \"\t\") {\n        return;\n      }\n      this.currentCharIndex++;\n    }\n  }\n  getToken() {\n    const pos0 = this.currentCharIndex++;\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar === \" \" || this.currentChar === \"\t\") {\n        break;\n      }\n      this.currentCharIndex++;\n    }\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n  }\n}\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n  cloneResult(original) {\n    const result = {};\n    result.faces = original.faces.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        controlPoints: face.controlPoints.map(v => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone())\n      };\n    });\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.subobjects = original.subobjects;\n    result.totalFaces = original.totalFaces;\n    result.startingConstructionStep = original.startingConstructionStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_AS_IS;\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = \"parts/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = \"p/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = \"models/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_AS_IS;\n          }\n          break;\n      }\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch (e) {\n        continue;\n      }\n    }\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n  parse(text, fileName = null) {\n    const loader = this.loader;\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n    const getLocalMaterial = colorCode => {\n      return materials[colorCode] || null;\n    };\n    let type = \"Model\";\n    let category = null;\n    let keywords = null;\n    let totalFaces = 0;\n    if (text.indexOf(\"\\r\\n\") !== -1) {\n      text = text.replace(/\\r\\n/g, \"\\n\");\n    }\n    const lines = text.split(\"\\n\");\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingConstructionStep = false;\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith(\"0 FILE \")) {\n          this.setData(currentEmbeddedFileName, currentEmbeddedText);\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = \"\";\n        } else {\n          currentEmbeddedText += line + \"\\n\";\n        }\n        continue;\n      }\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n      if (lp.isAtTheEnd()) {\n        continue;\n      }\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n      switch (lineType) {\n        case \"0\":\n          const meta = lp.getToken();\n          if (meta) {\n            switch (meta) {\n              case \"!LDRAW_ORG\":\n                type = lp.getToken();\n                break;\n              case \"!COLOUR\":\n                material = loader.parseColorMetaDirective(lp);\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                }\n                break;\n              case \"!CATEGORY\":\n                category = lp.getToken();\n                break;\n              case \"!KEYWORDS\":\n                const newKeywords = lp.getRemainingString().split(\",\");\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n                break;\n              case \"FILE\":\n                if (lineIndex > 0) {\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = \"\";\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n                break;\n              case \"BFC\":\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n                  switch (token) {\n                    case \"CERTIFY\":\n                    case \"NOCERTIFY\":\n                      bfcCertified = token === \"CERTIFY\";\n                      bfcCCW = true;\n                      break;\n                    case \"CW\":\n                    case \"CCW\":\n                      bfcCCW = token === \"CCW\";\n                      break;\n                    case \"INVERTNEXT\":\n                      bfcInverted = true;\n                      break;\n                    case \"CLIP\":\n                    case \"NOCLIP\":\n                      bfcCull = token === \"CLIP\";\n                      break;\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n                break;\n              case \"STEP\":\n                startingConstructionStep = true;\n                break;\n              default:\n                break;\n            }\n          }\n          break;\n        case \"1\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName2 = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n          if (loader.fileMap[fileName2]) {\n            fileName2 = loader.fileMap[fileName2];\n          } else {\n            if (fileName2.startsWith(\"s/\")) {\n              fileName2 = \"parts/\" + fileName2;\n            } else if (fileName2.startsWith(\"48/\")) {\n              fileName2 = \"p/\" + fileName2;\n            }\n          }\n          subobjects.push({\n            material,\n            colorCode,\n            matrix,\n            fileName: fileName2,\n            inverted: bfcInverted,\n            startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        case \"2\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n        case \"5\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n        case \"3\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n          break;\n        case \"4\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n          break;\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n      }\n    }\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null\n    };\n  }\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  }\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n    if (!(key in this._cache)) {\n      this._cache[key] = this.fetchData(fileName).then(text => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n    await this._cache[key];\n  }\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n}\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n  return materialHierarchy[colorCode] || null;\n}\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  }\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = /* @__PURE__ */new Set();\n    const processInfoSubobjects = async (info2, subobject = null) => {\n      const subobjects = info2.subobjects;\n      const promises = [];\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject2 = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject2.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject2.fileName, false);\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject2.fileName).catch(error => {\n              console.warn(error);\n              return null;\n            });\n          }\n          return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);\n        });\n        promises.push(promise);\n      }\n      const group2 = new Group();\n      group2.userData.category = info2.category;\n      group2.userData.keywords = info2.keywords;\n      info2.group = group2;\n      const subobjectInfos = await Promise.all(promises);\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject2 = info2.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n        if (subobjectInfo === null) {\n          continue;\n        }\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;\n          subobjectGroup.name = subobject2.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);\n          group2.add(subobjectGroup);\n          continue;\n        }\n        if (subobjectInfo.group.children.length) {\n          group2.add(subobjectInfo.group);\n        }\n        const parentLineSegments = info2.lineSegments;\n        const parentConditionalSegments = info2.conditionalSegments;\n        const parentFaces = info2.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject2.matrix;\n        const inverted = subobject2.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject2.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n        for (let i2 = 0, l2 = lineSegments.length; i2 < l2; i2++) {\n          const ls = lineSegments[i2];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);\n          parentLineSegments.push(ls);\n        }\n        for (let i2 = 0, l2 = conditionalSegments.length; i2 < l2; i2++) {\n          const os = conditionalSegments[i2];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);\n          parentConditionalSegments.push(os);\n        }\n        for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {\n          const tri = faces[i2];\n          const vertices = tri.vertices;\n          for (let i3 = 0, l3 = vertices.length; i3 < l3; i3++) {\n            vertices[i3].applyMatrix4(matrix);\n          }\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);\n          faceMaterials.add(tri.colorCode);\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n          parentFaces.push(tri);\n        }\n        info2.totalFaces += subobjectInfo.totalFaces;\n      }\n      if (subobject) {\n        loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);\n      }\n      return info2;\n    };\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n    await processInfoSubobjects(info);\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    }\n    const group = info.group;\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\n    }\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2));\n    }\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true));\n    }\n    return group;\n  }\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  }\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n    if (this.hasCachedModel(fileName)) {\n      return this.getCachedModel(fileName);\n    } else {\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info);\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      }\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      }\n      const group = await promise;\n      return group.clone();\n    }\n  }\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n    return this.processIntoMesh(info);\n  }\n}\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  elements.sort(sortByMaterial);\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n        _tempVec0.subVectors(v1, v0);\n        _tempVec1.subVectors(v2, v1);\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n      let elemNormals = elem.normals;\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        let n = elem.faceNormal;\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      const material = elem.material;\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        materials.push(elem.colorCode);\n      }\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n    offset += 3 * vertices.length;\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n  if (normals !== null) {\n    bufferGeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n  }\n  let object3d = null;\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n    bufferGeometry.setAttribute(\"control0\", new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute(\"control1\", new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute(\"direction\", new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n}\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.materials = [];\n    this.materialLibrary = {};\n    this.partsCache = new LDrawPartsGeometryCache(this);\n    this.fileMap = {};\n    this.setMaterials([]);\n    this.smoothNormals = true;\n    this.partsLibraryPath = \"\";\n  }\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, \"\");\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n    this.setMaterials(materials);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, text => {\n      this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n        this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n        this.computeConstructionSteps(group);\n        onLoad(group);\n      }).catch(onError);\n    }, onProgress, onError);\n  }\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n      this.computeConstructionSteps(group);\n      onLoad(group);\n    });\n  }\n  setMaterials(materials) {\n    this.materialLibrary = {};\n    this.materials = [];\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    }\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n    return this;\n  }\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n  addMaterial(material) {\n    const matLib = this.materialLibrary;\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n    return this;\n  }\n  getMaterial(colorCode) {\n    if (colorCode.startsWith(\"0x2\")) {\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(new LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color));\n    }\n    return this.materialLibrary[colorCode] || null;\n  }\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse(c => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    });\n    function getMaterial(c, colorCode) {\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n      let material = null;\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        material = loader.getMaterial(colorCode);\n        if (material === null) {\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n        }\n      } else {\n        return colorCode;\n      }\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial;\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial;\n        }\n      }\n      return material;\n    }\n  }\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n  }\n  parseColorMetaDirective(lineParser) {\n    let code = null;\n    let color = 16711935;\n    let edgeColor = 16711935;\n    let alpha = 1;\n    let isTransparent = false;\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n    if (!name) {\n      throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\");\n    }\n    let token = null;\n    while (true) {\n      token = lineParser.getToken();\n      if (!token) {\n        break;\n      }\n      switch (token.toUpperCase()) {\n        case \"CODE\":\n          code = lineParser.getToken();\n          break;\n        case \"VALUE\":\n          color = lineParser.getToken();\n          if (color.startsWith(\"0x\")) {\n            color = \"#\" + color.substring(2);\n          } else if (!color.startsWith(\"#\")) {\n            throw new Error(\"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\");\n          }\n          break;\n        case \"EDGE\":\n          edgeColor = lineParser.getToken();\n          if (edgeColor.startsWith(\"0x\")) {\n            edgeColor = \"#\" + edgeColor.substring(2);\n          } else if (!edgeColor.startsWith(\"#\")) {\n            edgeMaterial = this.getMaterial(edgeColor);\n            if (!edgeMaterial) {\n              throw new Error(\"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\");\n            }\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n          break;\n        case \"ALPHA\":\n          alpha = parseInt(lineParser.getToken());\n          if (isNaN(alpha)) {\n            throw new Error(\"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\");\n          }\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n          break;\n        case \"LUMINANCE\":\n          luminance = parseInt(lineParser.getToken());\n          if (isNaN(luminance)) {\n            throw new Error(\"LDrawLoader: Invalid luminance value in material definition\" + LineParser.getLineNumberString() + \".\");\n          }\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n        case \"CHROME\":\n          finishType = FINISH_TYPE_CHROME;\n          break;\n        case \"PEARLESCENT\":\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n        case \"RUBBER\":\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n        case \"MATTE_METALLIC\":\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n        case \"METAL\":\n          finishType = FINISH_TYPE_METAL;\n          break;\n        case \"MATERIAL\":\n          lineParser.setToEnd();\n          break;\n        default:\n          throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\");\n      }\n    }\n    let material = null;\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.3,\n          metalness: 0\n        });\n        break;\n      case FINISH_TYPE_PEARLESCENT:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.3,\n          metalness: 0.25\n        });\n        break;\n      case FINISH_TYPE_CHROME:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n      case FINISH_TYPE_RUBBER:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.9,\n          metalness: 0\n        });\n        break;\n      case FINISH_TYPE_MATTE_METALLIC:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n      case FINISH_TYPE_METAL:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n      default:\n        break;\n    }\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n    if (!edgeMaterial) {\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + \" - Edge\";\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha\n      });\n    }\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    this.addMaterial(material);\n    return material;\n  }\n  computeConstructionSteps(model) {\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n}\nexport { LDrawLoader };","map":{"version":3,"names":["Vector3","ShaderMaterial","UniformsUtils","UniformsLib","Color","REVISION","LineSegments","Ray","FileLoader","Matrix4","Group","BufferGeometry","BufferAttribute","Mesh","Loader","MeshStandardMaterial","LineBasicMaterial","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","_tempVec0","_tempVec1","LDrawConditionalLineMaterial","constructor","parameters","uniforms","merge","fog","diffuse","value","opacity","vertexShader","fragmentShader","parseInt","replace","Object","defineProperties","get","set","color","setValues","isLDrawConditionalLineMaterial","ConditionalLineSegments","geometry","material","isConditionalLine","generateFaceNormals","faces","i","l","length","face","vertices","v0","v1","v2","subVectors","faceNormal","crossVectors","normalize","_ray","smoothNormals","lineSegments","checkSubSegments","hashMultiplier","hashVertex","v","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","Set","hardEdgeRays","Map","halfEdgeList","normals","ls","add","rh1","has","rh2","info2","distances","info","d0","d1","push","tri","vertCount","i2","index","next","hash","rayHash","found","i3","l2","halfEdge","key","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","isPartType","type","isPrimitiveType","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getVector","parseFloat","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","LDrawParsedCache","loader","_cache","cloneResult","original","result","map","colorCode","clone","conditionalSegments","controlPoints","category","keywords","subobjects","totalFaces","startingConstructionStep","materials","group","fetchData","fileName","triedLowerCase","locationState","subobjectURL","lastIndexOf","toLowerCase","fileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","loadAsync","e","Error","parse","getLocalMaterial","indexOf","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","lineType","segment","ccw","doubleSided","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","newKeywords","forEach","keyword","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","fileName2","fileMap","inverted","getData","Promise","ensureDataLoaded","then","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","isPassthrough","LDrawPartsGeometryCache","parseCache","processIntoMesh","faceMaterials","processInfoSubobjects","subobject","promises","subobject2","promise","subobjectInfo","loadModel","catch","error","group2","subobjectInfos","all","isGroup","subobjectGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","children","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","determinant","lineColorCode","applyMatrix4","os","l3","reverse","size","createObject","hasCachedModel","getCachedModel","parseModel","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","conditionalEdgeMaterial","Infinity","setAttribute","object3d","controlArray0","controlArray1","directionArray","LDrawLoader","materialLibrary","partsCache","setMaterials","setPartsLibraryPath","path","preloadMaterials","url","colorLineRegex","directive","load","onLoad","onProgress","onError","computeConstructionSteps","addMaterial","setFileMap","matLib","getMaterial","finalMaterialPass","parentIsPassthrough","traverse","c","isMesh","isLineSegments","isArray","isMaterial","getMainMaterial","getMainEdgeMaterial","lineParser","edgeColor","alpha","isTransparent","luminance","finishType","toUpperCase","isNaN","max","min","roughness","metalness","transparent","premultipliedAlpha","depthWrite","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","model","stepNumber","constructionStep","numConstructionSteps"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/loaders/LDrawLoader.js"],"sourcesContent":["import { Vector3, ShaderMaterial, UniformsUtils, UniformsLib, Color, REVISION, LineSegments, Ray, FileLoader, Matrix4, Group, BufferGeometry, BufferAttribute, Mesh, Loader, MeshStandardMaterial, LineBasicMaterial } from \"three\";\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = \"16\";\nconst MAIN_EDGE_COLOUR_CODE = \"24\";\nconst _tempVec0 = /* @__PURE__ */ new Vector3();\nconst _tempVec1 = /* @__PURE__ */ new Vector3();\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([\n        UniformsLib.fog,\n        {\n          diffuse: {\n            value: new Color()\n          },\n          opacity: {\n            value: 1\n          }\n        }\n      ]),\n      vertexShader: (\n        /* glsl */\n        `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `\n      )\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        get: function() {\n          return this.uniforms.opacity.value;\n        },\n        set: function(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function() {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n    this.isLDrawConditionalLineMaterial = true;\n  }\n}\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n}\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n    _tempVec0.subVectors(v1, v0);\n    _tempVec1.subVectors(v2, v1);\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\nconst _ray = /* @__PURE__ */ new Ray();\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  const hashMultiplier = (1 + 1e-10) * 100;\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n  const hardEdges = /* @__PURE__ */ new Set();\n  const hardEdgeRays = /* @__PURE__ */ new Map();\n  const halfEdgeList = {};\n  const normals = [];\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n    if (checkSubSegments) {\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info2 = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info2);\n        hardEdgeRays.set(rh2, info2);\n      }\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n      if (d0 > d1) {\n        ;\n        [d0, d1] = [d1, d0];\n      }\n      info.distances.push(d0, d1);\n    }\n  }\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1);\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n        if (hardEdgeRays.has(rayHash)) {\n          const info2 = hardEdgeRays.get(rayHash);\n          const { ray, distances } = info2;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n          if (d0 > d1) {\n            ;\n            [d0, d1] = [d1, d0];\n          }\n          let found = false;\n          for (let i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {\n            if (d0 >= distances[i3] && d1 <= distances[i3 + 1]) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n        }\n      }\n      const info = {\n        index,\n        tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  }\n  while (true) {\n    let halfEdge = null;\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n    if (halfEdge === null) {\n      break;\n    }\n    const queue = [halfEdge];\n    while (queue.length > 0) {\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal;\n      const vertCount = vertices.length;\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next];\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal;\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          }\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n          const otherNext = (otherIndex + 1) % otherVertCount;\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n          if (sharedNormal1 === null) {\n            sharedNormal1 = { norm: new Vector3() };\n            normals.push(sharedNormal1.norm);\n          }\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n          if (sharedNormal2 === null) {\n            sharedNormal2 = { norm: new Vector3() };\n            normals.push(sharedNormal2.norm);\n          }\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\nfunction isPartType(type) {\n  return type === \"Part\" || type === \"Unofficial_Part\";\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === \"Subpart\";\n}\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = \" \";\n    this.lineNumber = lineNumber;\n  }\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar !== \" \" && this.currentChar !== \"\t\") {\n        return;\n      }\n      this.currentCharIndex++;\n    }\n  }\n  getToken() {\n    const pos0 = this.currentCharIndex++;\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar === \" \" || this.currentChar === \"\t\") {\n        break;\n      }\n      this.currentCharIndex++;\n    }\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n  }\n}\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n  cloneResult(original) {\n    const result = {};\n    result.faces = original.faces.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        controlPoints: face.controlPoints.map((v) => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone())\n      };\n    });\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.subobjects = original.subobjects;\n    result.totalFaces = original.totalFaces;\n    result.startingConstructionStep = original.startingConstructionStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_AS_IS;\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = \"parts/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = \"p/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = \"models/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_AS_IS;\n          }\n          break;\n      }\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch (e) {\n        continue;\n      }\n    }\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n  parse(text, fileName = null) {\n    const loader = this.loader;\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n    const getLocalMaterial = (colorCode) => {\n      return materials[colorCode] || null;\n    };\n    let type = \"Model\";\n    let category = null;\n    let keywords = null;\n    let totalFaces = 0;\n    if (text.indexOf(\"\\r\\n\") !== -1) {\n      text = text.replace(/\\r\\n/g, \"\\n\");\n    }\n    const lines = text.split(\"\\n\");\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingConstructionStep = false;\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0)\n        continue;\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith(\"0 FILE \")) {\n          this.setData(currentEmbeddedFileName, currentEmbeddedText);\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = \"\";\n        } else {\n          currentEmbeddedText += line + \"\\n\";\n        }\n        continue;\n      }\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n      if (lp.isAtTheEnd()) {\n        continue;\n      }\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n      switch (lineType) {\n        case \"0\":\n          const meta = lp.getToken();\n          if (meta) {\n            switch (meta) {\n              case \"!LDRAW_ORG\":\n                type = lp.getToken();\n                break;\n              case \"!COLOUR\":\n                material = loader.parseColorMetaDirective(lp);\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                }\n                break;\n              case \"!CATEGORY\":\n                category = lp.getToken();\n                break;\n              case \"!KEYWORDS\":\n                const newKeywords = lp.getRemainingString().split(\",\");\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n                  newKeywords.forEach(function(keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n                break;\n              case \"FILE\":\n                if (lineIndex > 0) {\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = \"\";\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n                break;\n              case \"BFC\":\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n                  switch (token) {\n                    case \"CERTIFY\":\n                    case \"NOCERTIFY\":\n                      bfcCertified = token === \"CERTIFY\";\n                      bfcCCW = true;\n                      break;\n                    case \"CW\":\n                    case \"CCW\":\n                      bfcCCW = token === \"CCW\";\n                      break;\n                    case \"INVERTNEXT\":\n                      bfcInverted = true;\n                      break;\n                    case \"CLIP\":\n                    case \"NOCLIP\":\n                      bfcCull = token === \"CLIP\";\n                      break;\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n                break;\n              case \"STEP\":\n                startingConstructionStep = true;\n                break;\n              default:\n                break;\n            }\n          }\n          break;\n        case \"1\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName2 = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n          if (loader.fileMap[fileName2]) {\n            fileName2 = loader.fileMap[fileName2];\n          } else {\n            if (fileName2.startsWith(\"s/\")) {\n              fileName2 = \"parts/\" + fileName2;\n            } else if (fileName2.startsWith(\"48/\")) {\n              fileName2 = \"p/\" + fileName2;\n            }\n          }\n          subobjects.push({\n            material,\n            colorCode,\n            matrix,\n            fileName: fileName2,\n            inverted: bfcInverted,\n            startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        case \"2\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n        case \"5\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n        case \"3\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n          break;\n        case \"4\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n          break;\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n      }\n    }\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null\n    };\n  }\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  }\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n    if (!(key in this._cache)) {\n      this._cache[key] = this.fetchData(fileName).then((text) => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n    await this._cache[key];\n  }\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n}\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n  return materialHierarchy[colorCode] || null;\n}\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  }\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = /* @__PURE__ */ new Set();\n    const processInfoSubobjects = async (info2, subobject = null) => {\n      const subobjects = info2.subobjects;\n      const promises = [];\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject2 = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject2.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject2.fileName, false);\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject2.fileName).catch((error) => {\n              console.warn(error);\n              return null;\n            });\n          }\n          return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);\n        });\n        promises.push(promise);\n      }\n      const group2 = new Group();\n      group2.userData.category = info2.category;\n      group2.userData.keywords = info2.keywords;\n      info2.group = group2;\n      const subobjectInfos = await Promise.all(promises);\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject2 = info2.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n        if (subobjectInfo === null) {\n          continue;\n        }\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;\n          subobjectGroup.name = subobject2.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);\n          group2.add(subobjectGroup);\n          continue;\n        }\n        if (subobjectInfo.group.children.length) {\n          group2.add(subobjectInfo.group);\n        }\n        const parentLineSegments = info2.lineSegments;\n        const parentConditionalSegments = info2.conditionalSegments;\n        const parentFaces = info2.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject2.matrix;\n        const inverted = subobject2.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject2.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n        for (let i2 = 0, l2 = lineSegments.length; i2 < l2; i2++) {\n          const ls = lineSegments[i2];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);\n          parentLineSegments.push(ls);\n        }\n        for (let i2 = 0, l2 = conditionalSegments.length; i2 < l2; i2++) {\n          const os = conditionalSegments[i2];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);\n          parentConditionalSegments.push(os);\n        }\n        for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {\n          const tri = faces[i2];\n          const vertices = tri.vertices;\n          for (let i3 = 0, l3 = vertices.length; i3 < l3; i3++) {\n            vertices[i3].applyMatrix4(matrix);\n          }\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);\n          faceMaterials.add(tri.colorCode);\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n          parentFaces.push(tri);\n        }\n        info2.totalFaces += subobjectInfo.totalFaces;\n      }\n      if (subobject) {\n        loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);\n      }\n      return info2;\n    };\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n    await processInfoSubobjects(info);\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    }\n    const group = info.group;\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\n    }\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2));\n    }\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true));\n    }\n    return group;\n  }\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  }\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n    if (this.hasCachedModel(fileName)) {\n      return this.getCachedModel(fileName);\n    } else {\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info);\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      }\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      }\n      const group = await promise;\n      return group.clone();\n    }\n  }\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n    return this.processIntoMesh(info);\n  }\n}\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  elements.sort(sortByMaterial);\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n        _tempVec0.subVectors(v1, v0);\n        _tempVec1.subVectors(v2, v1);\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n      let elemNormals = elem.normals;\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        let n = elem.faceNormal;\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      const material = elem.material;\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        materials.push(elem.colorCode);\n      }\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n    offset += 3 * vertices.length;\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n  if (normals !== null) {\n    bufferGeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n  }\n  let object3d = null;\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n    bufferGeometry.setAttribute(\"control0\", new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute(\"control1\", new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute(\"direction\", new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n}\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.materials = [];\n    this.materialLibrary = {};\n    this.partsCache = new LDrawPartsGeometryCache(this);\n    this.fileMap = {};\n    this.setMaterials([]);\n    this.smoothNormals = true;\n    this.partsLibraryPath = \"\";\n  }\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, \"\");\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n    this.setMaterials(materials);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(\n      url,\n      (text) => {\n        this.partsCache.parseModel(text, this.materialLibrary).then((group) => {\n          this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n          this.computeConstructionSteps(group);\n          onLoad(group);\n        }).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then((group) => {\n      this.computeConstructionSteps(group);\n      onLoad(group);\n    });\n  }\n  setMaterials(materials) {\n    this.materialLibrary = {};\n    this.materials = [];\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    }\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n    return this;\n  }\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n  addMaterial(material) {\n    const matLib = this.materialLibrary;\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n    return this;\n  }\n  getMaterial(colorCode) {\n    if (colorCode.startsWith(\"0x2\")) {\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(\n        new LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color)\n      );\n    }\n    return this.materialLibrary[colorCode] || null;\n  }\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse((c) => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    });\n    function getMaterial(c, colorCode) {\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n      let material = null;\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        material = loader.getMaterial(colorCode);\n        if (material === null) {\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n        }\n      } else {\n        return colorCode;\n      }\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial;\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial;\n        }\n      }\n      return material;\n    }\n  }\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n  }\n  parseColorMetaDirective(lineParser) {\n    let code = null;\n    let color = 16711935;\n    let edgeColor = 16711935;\n    let alpha = 1;\n    let isTransparent = false;\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n    if (!name) {\n      throw new Error(\n        'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\"\n      );\n    }\n    let token = null;\n    while (true) {\n      token = lineParser.getToken();\n      if (!token) {\n        break;\n      }\n      switch (token.toUpperCase()) {\n        case \"CODE\":\n          code = lineParser.getToken();\n          break;\n        case \"VALUE\":\n          color = lineParser.getToken();\n          if (color.startsWith(\"0x\")) {\n            color = \"#\" + color.substring(2);\n          } else if (!color.startsWith(\"#\")) {\n            throw new Error(\n              \"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\"\n            );\n          }\n          break;\n        case \"EDGE\":\n          edgeColor = lineParser.getToken();\n          if (edgeColor.startsWith(\"0x\")) {\n            edgeColor = \"#\" + edgeColor.substring(2);\n          } else if (!edgeColor.startsWith(\"#\")) {\n            edgeMaterial = this.getMaterial(edgeColor);\n            if (!edgeMaterial) {\n              throw new Error(\n                \"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\"\n              );\n            }\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n          break;\n        case \"ALPHA\":\n          alpha = parseInt(lineParser.getToken());\n          if (isNaN(alpha)) {\n            throw new Error(\n              \"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\"\n            );\n          }\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n          break;\n        case \"LUMINANCE\":\n          luminance = parseInt(lineParser.getToken());\n          if (isNaN(luminance)) {\n            throw new Error(\n              \"LDrawLoader: Invalid luminance value in material definition\" + LineParser.getLineNumberString() + \".\"\n            );\n          }\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n        case \"CHROME\":\n          finishType = FINISH_TYPE_CHROME;\n          break;\n        case \"PEARLESCENT\":\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n        case \"RUBBER\":\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n        case \"MATTE_METALLIC\":\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n        case \"METAL\":\n          finishType = FINISH_TYPE_METAL;\n          break;\n        case \"MATERIAL\":\n          lineParser.setToEnd();\n          break;\n        default:\n          throw new Error(\n            'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\"\n          );\n      }\n    }\n    let material = null;\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({ color, roughness: 0.3, metalness: 0 });\n        break;\n      case FINISH_TYPE_PEARLESCENT:\n        material = new MeshStandardMaterial({ color, roughness: 0.3, metalness: 0.25 });\n        break;\n      case FINISH_TYPE_CHROME:\n        material = new MeshStandardMaterial({ color, roughness: 0, metalness: 1 });\n        break;\n      case FINISH_TYPE_RUBBER:\n        material = new MeshStandardMaterial({ color, roughness: 0.9, metalness: 0 });\n        break;\n      case FINISH_TYPE_MATTE_METALLIC:\n        material = new MeshStandardMaterial({ color, roughness: 0.8, metalness: 0.4 });\n        break;\n      case FINISH_TYPE_METAL:\n        material = new MeshStandardMaterial({ color, roughness: 0.2, metalness: 0.85 });\n        break;\n      default:\n        break;\n    }\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n    if (!edgeMaterial) {\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + \" - Edge\";\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha\n      });\n    }\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    this.addMaterial(material);\n    return material;\n  }\n  computeConstructionSteps(model) {\n    let stepNumber = 0;\n    model.traverse((c) => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n}\nexport {\n  LDrawLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}