{"ast":null,"code":"import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper } from \"three\";\nfunction retarget(target, source, options = {}) {\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n  options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== void 0 ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || {\n          bone\n        };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(new VectorKeyframeTrack(\".bones[\" + boneData.bone.name + \"].position\", boneData.pos.times, boneData.pos.values));\n      }\n      convertedTracks.push(new QuaternionKeyframeTrack(\".bones[\" + boneData.bone.name + \"].quaternion\", boneData.quat.times, boneData.quat.values));\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = /* @__PURE__ */new Map();\n  const cloneLookup = /* @__PURE__ */new Map();\n  const clone2 = source.clone();\n  parallelTraverse(source, clone2, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone2.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nconst SkeletonUtils = {\n  retarget,\n  retargetClip,\n  clone\n};\nexport { SkeletonUtils };","map":{"version":3,"names":["Vector3","Quaternion","Matrix4","AnimationMixer","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationClip","SkeletonHelper","retarget","target","source","options","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","preserveMatrix","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","pose","i","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","clipAction","play","update","time","j","times","Float32Array","values","sub","toArray","uncacheAction","sourceLookup","Map","cloneLookup","clone2","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","Array","isArray","a","b","callback","SkeletonUtils"],"sources":["/home/atharv/gitPrograms/3djs/3djs/node_modules/three-stdlib/utils/SkeletonUtils.js"],"sourcesContent":["import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper } from \"three\";\nfunction retarget(target, source, options = {}) {\n  const pos = new Vector3(), quat = new Quaternion(), scale = new Vector3(), bindBoneMatrix = new Matrix4(), relativeMatrix = new Matrix4(), globalMatrix = new Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n  options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source), bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== void 0 ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new AnimationMixer(source), bones = getBones(target.skeleton), boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || { bone };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(\n          new VectorKeyframeTrack(\n            \".bones[\" + boneData.bone.name + \"].position\",\n            boneData.pos.times,\n            boneData.pos.values\n          )\n        );\n      }\n      convertedTracks.push(\n        new QuaternionKeyframeTrack(\n          \".bones[\" + boneData.bone.name + \"].quaternion\",\n          boneData.quat.times,\n          boneData.quat.values\n        )\n      );\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = /* @__PURE__ */ new Map();\n  const cloneLookup = /* @__PURE__ */ new Map();\n  const clone2 = source.clone();\n  parallelTraverse(source, clone2, function(sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone2.traverse(function(node) {\n    if (!node.isSkinnedMesh)\n      return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function(bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name)\n      return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nconst SkeletonUtils = { retarget, retargetClip, clone };\nexport {\n  SkeletonUtils\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}